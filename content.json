{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"搭建私有云存储","slug":"搭建私有云存储","date":"2019-05-04T08:14:40.000Z","updated":"2019-09-03T06:57:30.194Z","comments":true,"path":"2019/05/04/搭建私有云存储/","link":"","permalink":"http://yoursite.com/2019/05/04/搭建私有云存储/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/89814524 一、先废话一下 进入4G时代以来，用户数据已进入快速发展阶段，数据越来越多，无论是日常工作文件还是照片，视频和文件，数据都越来越大，4G时代的到来便于我们的备份，对于每日数据，我们会选择备份，这时，各种网络磁盘都充分利用了这一趋势，一时间，新浪网盘、360云盘、金山云盘、百度网盘等，网盘市场迎来了混战，此时，很多云盘都是免费或低价为用户提供50G、100G、1T甚至非常高的存储容量。 然而，美好时光并不长。从2016年上半年开始，大量云盘面临破产， 2016年3月；115个网络磁盘关闭了一些功能，2016年3月；UC网络磁盘宣布将终止存储服务，2016年4月25日；新浪微盘停止了正常的用户存储服务，关闭了新浪微搜索、共享功能，直到清理完为止，2016年4月26日；迅雷快递（原金山快盘）停止了个人用户的存储服务，所有用户数据将保留至2016年6月30日。 如今，也就只有部分厂商还在坚持着，比如百度网盘。然而，对于网络磁盘服务提供商来说，用户的海量数据存储、服务器维护、人员、场地和其他费用，这实在是一笔不小的开支。所以，剩下的云盘关闭也不是不可能的事情。当这些云盘破产时，我们存储在上面的数据就得再重新转移另一个云盘，如果不幸运的话，还可能直接被破产云盘删除了数据。在这样的情形下，越来越多企业和个体认识到搭建私有云的重要性。 二、配置 阿里云轻量应用服务器+可道云私有云 一开始其实是打算自己制作一个网盘框架，实现简单的上传、下载文件功能即可。后来，想到了搭建过程可能比较漫长，而且担心搞不定后台的业务逻辑，另外，现在是开源的时代，直接使用别人优秀的开源项目，是一个快速开发项目的方法。所以，就在网上找到了一个很好的项目——可道云私有云储存，这是开源的，免费下载使用。 然后，就是解决数据存储的问题。数据要储存到什么地方呢？首先想到的是把自己的电脑做成服务器，这样相对安全、可靠一些，不过这需要拥有比较大的硬盘空间，而且如果搭建好的私有云也只允许通过局域网访问，如果要实现外网访问还需要搞一个内网穿透，然而，这又可能会使你的电脑暴露在外网中，可能会受到黑客攻击，所以，安全性不高。所以，我就想到了云服务器。使用大厂的云服务器，即可以按需购买，又有大厂的安全架构保护着数据，更加的安全。我选择的是阿里云轻量应用服务器，因为对于学生有优惠，只需要9.5元/月。如果是企业的话，可以购买大内存虚拟主机，价格还是比较便宜的。 三、搭建过程前期准备： 服务器： 阿里云专门推出的云翼计划，为广大学生提供优惠服务，只需要认证后，就能享受到优惠。我使用的是轻量应用服务器，它的好处是不需要自己搭建服务器环境，即可快速搭建应用。配置是1核2GCPU，1000G流量包，5M峰值带宽，40G SSD盘。如果只是存储一些文档，那是足够使用了。 可道云： 一个开源项目，可以直接下载使用，跟网盘的功能差不多，上传、下载、分享等功能都拥有，而且下载速度与购买的服务器相关，速度都挺快的。 下载网址：https://kodcloud.com/download/ 开始搭建： 1）下载filezilla 连接服务器使用的是阿里云自己的filezilla，直接下载客户端 下载网址：https://www.filezilla.cn/?avia_forced_reroute=1 ，根据自己的平台下载相应客户端。这里选择的是window 64位 安装版 2）运行filezilla，输入服务器ip，用户名，密码连接服务器 3）上传项目 解压下载好的可道云项目，在filezilla中找到项目文件目录，清空服务器的/home/www/htdocs目录中的所有内容，然后把项目文件上传到此目录中。 4）测试 测试网址可以登录阿里云查找，这里的是http://120.77.179.154 在浏览器中输入http://120.77.179.154进行访问，会提示以下错误 解决方法：远程连接服务器，修改htdocs目录的读写权限 重新在浏览器中输入http://120.77.179.154进行访问 重新设置密码，然后登录，大功告成。 测试文件上传 5)域名绑定 直接使用ip访问可能不太方便，可以购买域名，然后解析到服务器ip，就可以直接使用域名进行访问了，以前有搞过域名绑定，现在域名已经过期了，现在的私有云觉得没这必要用域名，就没有进行这个步骤。需要的话，可以看我之前写的教程https://blog.csdn.net/qq_39110538/article/details/81164370 四、总结 在成功搭建属于自己的私有云后，感觉非常有成就感。从开始思考到最终实现大概花了几天的时间，大部分时间在考虑使用什么架构，实现只用了半天时间。其实这个搭建流程与搭建网站是一样的，首先得有个前后端项目，然后是服务器，最后部署即可。这个过程并没有涉及编程，之后的话，可能会自己去写前后端，实现私有云的业务逻辑，最后同样部署到服务器上。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"私有云","slug":"私有云","permalink":"http://yoursite.com/tags/私有云/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"编译原理1","slug":"编译原理1","date":"2019-04-24T14:19:06.000Z","updated":"2019-09-03T06:56:36.223Z","comments":true,"path":"2019/04/24/编译原理1/","link":"","permalink":"http://yoursite.com/2019/04/24/编译原理1/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/89504217 本学期学习编译原理，挺难的，但只要搞懂了会发现挺有意思的，分享一下自己学习整理的笔记。 编译原理是程序员的基础课之一，希望大家也要努力学好，加油加油!!! 建议放大看 编译阶段： 前端：（依赖于语言不依赖目标机） 词法分析：读取源程序，单词分类 语法分析：分析单词，组成单词序列 语义分析：审查语法错误 分界线：生成中间代码：生成结构简单、含义明确的记号系统 后端：（依赖目标机，一般不依赖语言） 代码优化：对中间代码优化 生成目标代码：将中间代码转换成机器指令（汇编指令） 编译程序的结构： 六个阶段的程序 表格管理程序：源程序的信息保留在许多不同的表格中，编译的各个阶段涉及了构造、查找、更新这些表格 出错处理程序：源程序编译过程出错，需报告错误性质和发生地点，缩小影响范围，使其余部分继续执行 ”遍“和”趟“ 多遍，少内存，时间长 少遍，多内存，时间短 编译程序与解释程序的区别 编译程序：把源代码一次性翻译成目标代码，程序才能运行；只需要编译一次，程序就可以以机器速度运行 解释程序：不需事先把源代码翻译成目标代码，而是一行一行地翻译代码，并生成结果；交互性好，但每次运行代码都需要翻译，且速度慢，空间开销大 处理源程序的软件工具 语言的结构化编辑器 语言程序的调试工具 程序格式化工具 语言程序的测试工具 程序理解工具 高级语言转换工具","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/编译原理/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"Matlab Simulink模块","slug":"Matlab Simulink模块","date":"2019-03-23T08:11:08.000Z","updated":"2019-09-03T09:29:19.877Z","comments":true,"path":"2019/03/23/Matlab Simulink模块/","link":"","permalink":"http://yoursite.com/2019/03/23/Matlab Simulink模块/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/88762814 Simulink 基本模块 1、输入信号源模块库（Source） Constant 恒值常数，可设置数值 Step 阶跃信号 Ramp 线性增加或减少的信号 Sine Wave 正弦波输出 Signal Generator 信号发生器，可产生正弦、方波、锯齿波和随机波信号 From File 从文件获取数据 From Workspace 从当前工作空间定义的矩阵读数据 Clock 仿真时钟，输出每个仿真步点的时间 In 输入模块 2、接收模块库（Sinks) Scope 显示器，显示实时信号 Display 实时数据显示 XY Graph 显示X-Y两个信号的关系图 To File 把数据保存文件 To Workspace 把数据写成矩阵输出到工作空间 Stop Simulation 输入不为零时终止仿真，常与关系模块配合使用 Out 输出模块 3、连续系统模块库（Continuous) Integrator 积分环节 Denvative 微分环节 State-Space 状态方程模型 Transfer Fcn 传递函数模型 Zero-Pole 零一极点增益模型 Transport Delay 把输入信号按给定的时间做延时 4、离散系统模块库(Discrete) Discrete Tranfer Fcn 离散传递函数模型 Discrete Zero-Pole 离散零极点增益模型 Discrete Filter 离散滤波器 Zero-Order Hold 零阶保持器 First-Order Hold 一阶保持器 Unit Delay 采样保持，延迟一个周期","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"Matlab 2016a 安装教程【转】","slug":"Matlab 2016a 安装教程【转】","date":"2019-02-16T06:00:23.000Z","updated":"2019-09-03T09:29:16.658Z","comments":true,"path":"2019/02/16/Matlab 2016a 安装教程【转】/","link":"","permalink":"http://yoursite.com/2019/02/16/Matlab 2016a 安装教程【转】/","excerpt":"","text":"亲测可用的教程https://blog.csdn.net/lalala8866/article/details/77454198不过博主里面的安装密钥是无效的，下面这个可以Matlab 2016a 安装密钥：09806-07443-53955-64350-21751-41297","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"python思维导图","slug":"python思维导图","date":"2019-02-11T02:49:45.000Z","updated":"2019-09-03T09:30:27.204Z","comments":true,"path":"2019/02/11/python思维导图/","link":"","permalink":"http://yoursite.com/2019/02/11/python思维导图/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86982022","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"python进阶语法2","slug":"python进阶语法2","date":"2019-02-11T02:10:36.000Z","updated":"2019-09-03T09:30:20.509Z","comments":true,"path":"2019/02/11/python进阶语法2/","link":"","permalink":"http://yoursite.com/2019/02/11/python进阶语法2/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86915150 目录 异常 概念 捕获异常 1、基本异常 2、错误类型捕获 3、捕获未知错误 4、异常捕获完整语法 5、异常的传递 6、抛出raise异常 模块的扩展 模块的导入方法 from…import 导入模块的部分工具 from…import * 导入模块所有工具 模块的搜索顺序 原则——每一个文件都应该是可以被导入的包 作用：使用import 包名 可以一次性导入包中所有的模块 制作并发布自己的模块压缩包 安装模块压缩包 卸载已安装好的模块 pip安装第三方模块 文件 1、文件类型 2、操作文件的套路 文件指针 readline方法 文件/目录的常用管理操作 文件操作 目录操作 python 2.x中如何使用中文 eval函数 异常概念 异常：程序在运行时，如果解析器遇到一个错误，会停止程序的执行，并且提示一些错误信息 抛出异常：程序停止执行并且提示错误信息这个动作 异常处理：就是通过对异常处理，把抛出的异常信息只给开发人员看，而不是最终用户看 程序开发时，很难将所有的特殊情况都处理得面面俱到，通过异常捕获可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性 捕获异常 1、基本异常 在程序开发中，如果对某些代码的执行不能确定是否正确，可以添加try(尝试) 来捕获异常 语法格式： 1234 try: 尝试执行的代码except: 出现错误的处理 2、错误类型捕获 在程序执行时，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的响应，这时需要捕获错误类型 语法格式： 123456 try: 尝试执行的代码except 错误类型1： 错误类型1的处理代码except (错误类型2，错误类型3)： 针对错误类型2和错误类型3的处理代码 当python解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型### 3、捕获未知错误 在开发时，要预判所有可能出现的错误，还是有一定难度的 如果希望程序无论出现任何错误，都不会因为python解析器抛出异常而被终止，可以再增加一个except 语法格式： 12345678 try: 尝试执行的代码except 错误类型1： 错误类型1的处理代码except (错误类型2，错误类型3)： 针对错误类型2和错误类型3的处理代码except Exception as result: print（“未知错误 %s” % result） 4、异常捕获完整语法123456789101112 try: 尝试执行的代码except 错误类型1： 错误类型1的处理代码except (错误类型2，错误类型3)： 针对错误类型2和错误类型3的处理代码except Exception as result: print（“未知错误 %s” % result）else: 没有异常才会执行的代码finally: 无论是否有异常都会执行的代码 5、异常的传递 当函数、方法执行出现异常，会将异常传递给函数、方法的调用者 如果传递到主程序任然没有异常处理，程序才会被终止 作用： 在开发中，可以在主程序增加异常处理 而在主程序调用的其他函数，只要出现异常，都会被传递到主程序的异常捕获中 这样就不需要在代码中，增加大量的异常捕获 6、抛出raise异常 除了代码执行错误抛出异常外，某些程序还希望主动抛出异常，比如规定密码长度不小于8，否则抛出异常 适用于需要自定义某些自定义规则，当不符合规则，就抛出异常的场景 过程 1、创建一个Exception的对象 2、使用raise关键字抛出异常对象 语法实例： 123456789101112131415161718 def input_password(): #1、提示用户输入密码 pwd = input(&quot;请输入密码:&quot;) #2、判断密码&gt;=8,返回输入的密码 if len(pwd) &gt;= 8: return pwd #3、如果&lt;8 主动抛出异常 #3.1、创建异常对象 ex = Exception(&quot;密码长度不够&quot;) #3.2、抛出异常 raise ex#4、对主程序进行异常处理try: print(input_password())except Exception as result: print(result) 模块的扩展模块的导入方法 1）import 模块名1，模块名2 2）import 模块名1 import 模块名2 提示：PE8推荐使用第二种规则，每个导入应该独占一行 导入之后，通过 模块名. **使用模块提供的工具——全局变量、函数、类** 拓展：如果模块名过长，可以使用别名、 import 模块名1 as 模块别名 注意：模块别名符合大驼峰命名法 from…import 导入模块的部分工具 使用 from 模块名 import 工具 导入模块的工具 调用时不需要用模块名.使用工具，可以直接使用模块提供的工具 注意：如果两个模块，存在同名函数，后导入模块的函数或覆盖掉先导入的函数 把所有导入代码应该统一写在代码的顶部，更容易及时发现冲突 一旦发现冲突，可以使用as关键字对其中一个工具起一个别名 from…import * 导入模块所有工具 这种方式不推荐使用，因为函数重名没有任何提示，出现错误不好排除 模块的搜索顺序 搜索当前目录指定模块名的文件，如果有直接导入 如果没有，再搜索系统目录 在开发时，给文件起名，不要和系统的模块文件重名 每一个模块都有一个内置属性file可以查看模块的完整路径，语法：print(模块名.file) 原则——每一个文件都应该是可以被导入的 在导入文件时，文件中所有没有任何缩进的代码都会被执行一遍！！！ 导入文件时，只是用模块的全局变量、函数、类，不需要执行除此之外的代码（比如测试代码） 解决方法：name属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入是不会被执行 如果直接执行程序，print(name)就会输出main ;如果是被其他文件导入的，就会输出模块名 所以解决方法就是给测试代码块添加一个判断语句，只有name等于main时才执行测试代码 实例： 12if __name__ = &quot;__main__&quot;: main() 包 包是一个包含多个模块的特殊目录 目录下有一个特殊文件init.py 包的命名方法符合变量命名规则 作用：使用import 包名 可以一次性导入包中所有的模块 需要在外界使用包中的模块，需要在init.py中指定对外界提供的模块列表 1from . import 模块名 ## 制作并发布自己的模块压缩包 1、把制作好的包复制到一个发布文件夹中 2、在发布文件中新建一个setup.py文件，粘贴以下代码 12345678910 from distutils.core import setupsetup(name = &quot;包名&quot;, version = &quot;版本&quot;, description = &quot;描述信息&quot;, long_description = &quot;详细信息&quot;, author = &quot;作者&quot;, author_email = &quot;作者邮箱&quot;, url = &quot;主页&quot;, py_modules = [&quot;包名.模块名1&quot;,&quot;包名.模块名2&quot;] ) #发布的模块列表 3、在终端或命令行使用命令构建模块 1$ python3 setup.py build 4、在终端或命令行生成发布压缩包 1$ python3 setup.py sdist ## 安装模块压缩包 1、解压模块压缩包 1$ tar -zxvf 发布模块压缩包名.tar.gz 2、安装模块压缩包，会安装到系统目录中 1$ sudo python3 setup.py install 卸载已安装好的模块 直接从安装目录下，把安装模块的目录删除就可以了 pip安装第三方模块 第三方模块通常是指由知名的第三方团队开发的并且被程序员广泛使用的python包/模块 pip是一个现代的，通用的python包管理工具 提供了对python包的查找、下载、安装、卸载等功能 安装卸载命令 1234567 # 将模块安装卸python2.x 环境和卸载$ sudo pip install 包名$ sudo pip uninstall 包名# 将模块安装卸python3.x 环境和卸载$ sudo pip3 install 包名$ sudo pip3 uninstall 包名 文件1、文件类型 文本文件和二进制文件 2、操作文件的套路 三个步骤：打开open、操作read/write、关闭close open函数的第一个参数是要打开的文件名（文件名区分大小写），第二个参数的访问方式（r w a r+ w+ a+），默认是只读方式打开 如果文件存在，返回文件操作对象 如果文件不存在，会抛出异常 read方法可以一次性读入并返回文件的所有内容 close方法负责关闭文件，如果忘记关闭文件，会造成系统资源消耗，而且会影响后续对文件的访问 123456 file = open(&quot;文件名&quot;)text = file.read()print(text)file.close() 文件指针 文件指针标记从哪个位置开始读取数据 第一次打开文件时，通常文件指针会指向文件的开始位置 当执行了read方法后，文件指针会移动到读取内容的末尾，如果再次执行read方法，不能读取到内容 readline方法 可以一次读取一行内容 方法执行后，会把文件指针移动到下一行，准备再次读取 文件/目录的常用管理操作文件操作方法名 | 说明 | 实例 ------ | ----- | --------------------- rename | 重命名文件 | os.rename(源文件名，目标文件名) remove | 删除文件 | os.remove(文件名) ### 目录操作方法名 | 说明 | 实例 ---------- | ------- | ------------------- listdir | 目录列表 | os.listdir(目录名) mkdir | 创建目录 | os.mkdir(目录名) rmdir | 删除目录 | os.rmdir(目录名) getcwd | 获取当前目录 | os.getcwd() chdir | 修改工作目录 | os.chdir(目标目录) path.isdir | 判断是否是文件 | os.path.isdir(文件路径)python 2.x中如何使用中文 要运行带有中文的文件，在第一行增加以下代码 1# *-* coding:utf8 *-* 也可以使用 1# coding=utf8 unicode字符串 要能够正确遍历字符串，在定义字符串时，需要在字符串的引导前，增加一个小写字母u，告诉解析器这是一个unicode字符创（使用utf-8编码格式的字符串） eval函数 将字符串当成有效的表达式来求值并返回计算结果 开发时千万不要使用eval直接转换input的结果，会有个接口能够操作文件/目录","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"python-进阶语法1","slug":"python-进阶语法1","date":"2019-02-10T08:56:33.000Z","updated":"2019-09-03T09:30:13.744Z","comments":true,"path":"2019/02/10/python-进阶语法1/","link":"","permalink":"http://yoursite.com/2019/02/10/python-进阶语法1/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86741864 目录 一、变量进阶 变量的引用 引用的概念 函数的参数和返回值的传递 可变和不可变类型 哈希 缺省参数 多值参数 元组和字典的拆包 函数的递归 二、面向对象（OOP） （一）概念 类的概念——相当于一张图纸 对象的概念——用图纸制造出来的物体 （二）面向对象基础语法 dir内置函数 定义类 创建对象 （三）封装 身份运算符 is 与 == 区别 私有属性和私有方法 （四）继承 方法的重写 父类的私有属性和私有方法 （五）多继承 python中的MRO——方法搜索顺序 新式类和旧式类 （六）多态 术语 类是一个特殊的对象 静态方法 （七）单例 单例设计模式 new方法 创建单例 初始化工作只执行一次 一、变量进阶变量的引用 变量 *和 *数据 都是保存在** 内存** 中的 在 python 中 函数 **的参数传递** 以及 *返回值 *都是靠 *引用 *传递的 引用的概念 变量 和 数据是分开存储的 数据保存在内存中的一个位置 变量中保存着数据在内存的地址 变量中记录数据的地址，就叫引用 使用 id() 函数可以查看变量保存数据所在的内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，实质是修改了数据的引用 变量不再对之前的数据引用 变量改为对新赋值的数据引用 函数的参数和返回值的传递 函数的实参/返回值 都是靠引用来传递的 传递的都是数据在内存中的地址（即引用），而不是数据本身 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int，float，bool，complex，long(z,x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改 列表 list 字典 dict 注意： 字典的key只能使用不可变类型的数据 可变类型的数据变化，是通过方法来实现的 哈希 接收一个不可变类型的数据作为参数 返回结果是一个整数 哈希是一种算法，作用是提取数据的特征码 相同的内容得到相同的结果 不相同的内容得到不相同的结果 在python中，设置字典的键值对是，会首先对key进行hash已决定如何在内存中保存字典的数据，方便后续对字典的操作：增、删、改、查 键值对的key必须是不可变类型数据 键值对的value可以是任意类型的数据 缺省参数 定义函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数 调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值 使用最常见的值作为默认值 如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递 注意： 缺省参数的定义位置必须保证在参数列表末尾 调用带有多个缺省参数的函数，需要指定参数名 多值参数 有时候可能需要一个函数能够处理的参数个数是不确定的，这个时候就可以使用多值参数 参数名前增加一个可以接收元组，一般使用**args**——存放元组参数 参数名前增加两个可以接收字典，一般使用***kwargs**——存放字典参数 元组和字典的拆包 在调用带有多值参数的函数时，希望将一个元组变量，直接传递 函数的递归 在函数内部自己调用自己，函数内部的代码是相同的，只是针对参数不同，处理的结果不同 必须要有递归的出口，当参数满足某个条件时，不再执行函数，如果没有出口会出现死循环 二、面向对象（OOP） 相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法 使用与复杂项目开发，提供固定套路 （一）概念类的概念——相当于一张图纸 类是对一群具有相同特征或者行为的事物的一个统称，是抽象不能直接使用的 特征被称为属性，行为被称为方法 设计类: 类名：满足大驼峰命名法 属性：这类事物具有什么样的特征 方法：这类事物具有什么样的行为 对象的概念——用图纸制造出来的物体 对象是由类创建出来的一个具体存在，可以直接使用 有哪个类创建的对象，就拥有哪个类中定义的属性和方法 （二）面向对象基础语法dir内置函数 可查看对象内的所有属性及方法 方法名格式的方法是python提供的内置方法/属性 定义类 1234567class 类名: def 方法1(self,参数列表): pass def 方法2(self,参数列表): pass 注意：第一个参数必须是self，哪一个对象调用的方法，self就是哪一个对象的引用（对象的内存地址） 在方法内部，可以通过self访问对象的属性，和调用其他的对象方法 创建对象1对象变量 = 类名() 一个类可以创建多个对象 注意：在日常开发中，不推荐在类的外部给对象增加属性，如果在运行时没有找到属性，程序会报错，对象应该包含有哪些属性，应该封装在类的内部 （三）封装 是面向对象编程的一大特点 将属性和方法封装到一个抽象的类中 外界使用类创建对象，然后让对象调用方法 对象方法的细节都被封装在类的内部 在对象的方法中，是可以直接访问类的属性 同一个类创建的多个对象之间，属性互不干扰 一个对象的属性可以是另外一个类创建的对象 身份运算符 身份运算符用于比较两个对象的内存地址是否一致——是否是对同一个对象的引用 针对None比较时，建议使用is判断 运算符 | 描述 | 实例 ------ | ------------------------ | ---------------------------- is | is是判断两个标识符是不是引用同一个对象 | x is y 类似 id(x) == id(y) is not | is not 是判断两个标识符是不是引用不同对象 | x is not y, 类似id(a) != id(b)is 与 == 区别 is用于判断两个变量引用对象是否同一个 == 用于判断引用变量的值是否相等 私有属性和私有方法 对象的某些属性或方法可能只希望在对象的内部被使用，而不希望在外部被访问到 私有属性就是对象不希望公开的属性 私有方法就是对象不希望公开的方法 定义方式 在定义属性或方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性或方法 （四）继承 继承实现代码的重用，相同的代码不需要重复的编写 子类拥有父类的所有方法和属性 实例语法 12class 类名(父类名): pass 子类继承父类，可以直接使用父类中已经封装好的方法，不需要再次开发 子类中应该根据职责，封装子类特有的属性和方法 专业术语 子类 == 派生类 父类 == 派生类 继承 == 派生 继承具有传递性，子类可以继承爷爷类 方法的重写 两种情况： 1）覆盖父类的方法 父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新填写父类的方法实现，重写后，只会调用子类中重写的方法，而不会调用父类封装的方法 2）对父类方法进行扩展 子类的方法实现中包含父类的方法实现，父类原本封装的方法实现是子类方法的一部分（即子类中还需要用到父类的方法，而又想再定义更多的方法） 使用方法是 super().父类方法 来调用父类方法的执行 当父类的方法实现不能满足子类需求是，可以对方法进行重写 父类的私有属性和私有方法 子类对象不能再自己的方法内部，直接访问父类的私有属性或私有方法 子类对象可以通过父类的公有方法间接访问到私有属性或私有方法 （五）多继承 子类可以具有多个父类，并且拥有所有父类的属性和方法 语法实例： 1class 子类名（父类1， 父类2, ...） 注意：如果不同的父类中存在同名的方法，子类对象调用方法时，会调用哪一个父类的方法呢？ 开发时，应该尽量避免这种容易产生混淆的情况，如果父类之间存在同名的属性或者方法，应该尽量避免使用多继承 ## python中的MRO——方法搜索顺序 提供一个内置属性mro可以看到方法搜索顺序 MRO主要用于多继承时判断方法、属性的调用路径 新式类和旧式类 object是python为所有对象提供的基类，提供有一些内置的属性和方法，可以使用dir函数查看 新式类：以object为基类的类，推荐使用 旧式类：不以object为基类的类，不推荐使用 在python 3.x中定义类时，如果不指定父类，就会默认使用object 为基类，所以都是新式类 在python 2.x中定义类时，如果不指定父类，就不会以object为基类，所以是旧式类 为保证同时在python 2.x 和 3.x中运行，定义类时，统一继承自object （六）多态 不同的子类调用相同的父类时，产生不同的执行结果 多态可以增加代码的灵活性 以继承和重写父类方法为前提 是调用方法的技巧，不会影响类的内部设计# 术语 创建出来的对象叫做类的实例 创建对象的动作叫做实例化 对象的属性叫做实例属性 对象调用的方法叫做实例方法 类是一个特殊的对象 在程序运行时，类同样会被加载到内存中 类是一个特殊的对象——类对象 程序运行时，类对象在内存中只有一份，使用一个类可以创建很多个对象实例 除了封装实例的属性和方法，类对象还可以拥有自己的属性和方法——类属性、类方法 类属性： 就是给类对象中定义的属性 通常用来记录与这个类相关的特征（模板） 类属性不会用于记录具体对象的特征（实例） 属性的获取机制——向上查找机制 1.类名.类属性 2.对象.类属性（不推荐） 注意：使用对象名.类属性 = 值 赋值语句，只会给对象添加一个属性，而不会影响到类属性的值 类方法: 定义类方法：需要用修饰器@classmethod来标识，告诉解释器这是一个类方法，第一个参数应该是cls，与self类似 123 @classmethoddef 类方法名(cls): pass # 静态方法 如果需要封装一个方法，即不需要访问实例属性或者调用实例方法，也不需要访问类属性或者调用类方法，就可以封装成静态方法 1234 @staticmethoddef 静态方法名(): pass 通过 类名. 的方法直接调用静态方法，不需要创建对象 类属性和实例属性的区别：类属性就相当于全局属性，比如记录该类创建了多少个对象；实例属性就相当于局部属性，每个对象的属性都不一样，互不影响（实例属性下初始化方法中定义） 五大概念：类属性、类方法、实例属性、实例方法、静态方法 （七）单例单例设计模式 让类创建的对象，在系统中只有唯一一个实例 每一次执行 类名()返回的对象，内存地址是相同的 new方法 功能 在内存中为对象分配空间 返回对象的引用 重写new方法一定要return super().new(cls) 否则解析器得不到分配了空间的对象引用，就不会调用对象的初始化方法 new是一个静态方法，在调用时需要主动村传递cls参数 创建单例 定义一个类属性，初始值是None,用于记录单例对象的引用 重写new方法 如果类属性is None ,调用父类方法分配空间，并在类属性中记录结果 返回类属性中记录的对象引用 初始化工作只执行一次 定义一个类属性 init_flag 标记是否执行过初始化动作，初始值为False 在init方法中，判断init_flag, 如果为false就执行初始化动作 然后将init_flag设置为True 这样，再次自动调用 init 方法时，初始化动作就不会被再次执行了","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Python实战——斗图网爬虫","slug":"Python实战——斗图网爬虫","date":"2019-02-07T05:23:47.000Z","updated":"2019-09-03T09:30:23.321Z","comments":true,"path":"2019/02/07/Python实战——斗图网爬虫/","link":"","permalink":"http://yoursite.com/2019/02/07/Python实战——斗图网爬虫/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86771215 导入的包 request 一个很实用的python HTTP客户端库，编写爬虫和测试服务器响应数据时经常会用到 语法实例： 123 import requestsr = requests.get(&apos;https://api.github.com/events&apos;) ## bs4 全名BeautifulSoup，是编写python爬虫常用库之一，主要用来解析html标签 语法实例： 12345 from bs4 import BeautifulSoupsoup = BeautifulSoup(&quot;&lt;html&gt;A Html Text&lt;/html&gt;&quot;,&quot;html.parser&quot;)# 第一个参数是要解析的html文本，第二个参数是使用哪种解析器 request 和 bs4 的安装方法https://blog.csdn.net/qq_39110538/article/details/86770501 os 包含普遍的操作系统功能，如果希望程序能够与平台无关的话，os允许一个程序编写后不需要任何改动，也不会发生任何问题，就可以在Linux和Windows下运行 教程：https://www.cnblogs.com/mufenglin/p/7676160.html threading 为了提升程序的执行速度，经常会使用到多线程，threading就是使你的程序能够以多线程的方式去执行 教程：https://www.cnblogs.com/xiaobeibei26/p/6481707.html urllib urllib提供了一系列用于操作URL的功能 教程：https://www.cnblogs.com/ifso/p/4707135.html os threading urllib 在python中已经自带的，直接使用import导入即可，如果使用过程中发现缺少了，就可以使用一下方法安装导入 https://blog.csdn.net/qq_39110538/article/details/86770501 ## 生产者消费者模式 某个模块负责产生数据，这些数据由另一个模块来负责处理。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。 该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据 程序源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 # 导入包import urllibimport requestsfrom bs4 import BeautifulSoupimport osimport threading# 所有页面BASE_PAGE_URL = &apos;http://www.doutula.com/photo/list/?page=&apos;PAGE_URL_LIST = [] # 页面的urlFACE_URL_LIST = [] # 所有表情的urlgLock = threading.Lock() # 全局锁for x in range(1,870): url = BASE_PAGE_URL + str(x) PAGE_URL_LIST.append(url)# 生产者，抓取网页urldef producer(): while True: gLock.acquire() if len(PAGE_URL_LIST) == 0: gLock.release() break else: page_url = PAGE_URL_LIST.pop() gLock.release() response = requests.get(page_url) content = response.content soup = BeautifulSoup(content, &apos;lxml&apos;) img_list = soup.find_all(&apos;img&apos;, attrs=&#123;&apos;class&apos;: &apos;img-responsive lazy image_dta&apos;&#125;) gLock.acquire() for img in img_list: url = img[&apos;data-original&apos;] if not url.startswith(&apos;http&apos;): url = &apos;http&apos; + url FACE_URL_LIST.append(url) gLock.release()# 消费者下载图片def customer(): while True: gLock.acquire() if len(FACE_URL_LIST) == 0: gLock.release() continue else: face_url = FACE_URL_LIST.pop() gLock.release() split_list = face_url.split(&apos;/&apos;) filename = split_list.pop() path = os.path.join(&apos;images&apos;, filename) urllib.request.urlretrieve(face_url, filename=path)def main(): # 创建两个多线程作为生产者，去爬取表情的url for x in range(2): th = threading.Thread(target=producer) th.start() # 创建4个多线程作为消费者，去把表情下载下来 for x in range(4): th = threading.Thread(target=customer()) th.start()if __name__ == &quot;__main__&quot;: main() ###","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"pycharm导入requests和beautifulSoup","slug":"pycharm导入requests和beautifulSoup","date":"2019-02-07T01:47:12.000Z","updated":"2019-09-03T09:29:56.226Z","comments":true,"path":"2019/02/07/pycharm导入requests和beautifulSoup/","link":"","permalink":"http://yoursite.com/2019/02/07/pycharm导入requests和beautifulSoup/","excerpt":"","text":"1、在pycharm界面 , File -&gt; Setting或(Ctrl + Alt + S) 进入 setting 界面 2、进入 Project Interpreter界面 3、安装bs4 若是出现如下错误 那你别在这里整了，这里是中文版的官网安装bs4教程 直接进cmd命令，输入pip install beautifulsoup4 4、安装requests库 cmd命令行：pip install requests cmd命令行：pip install requests -i http://pypi.douban.com/simple –trusted-host pypi.douban.com 其他源总结： 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 使用方法很简单，直接 -i 加 url 即可！如下： 关于requests的安装pip源 原文：https://blog.csdn.net/qq_15028305/article/details/86076363","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://yoursite.com/tags/Pycharm/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"python-如何运行py程序","slug":"python-如何运行py程序","date":"2019-02-01T07:29:40.000Z","updated":"2019-09-03T09:30:16.875Z","comments":true,"path":"2019/02/01/python-如何运行py程序/","link":"","permalink":"http://yoursite.com/2019/02/01/python-如何运行py程序/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86741708 在window环境下运行py程序 一种简单的方法是用批量处理命令打开.py文件，方法如下： 1、在py文件同目录下新建一个txt文件，粘贴虾下面命令 1start py -3 &quot;要运行的文件.py&quot; 2、修改文件后缀为bat文件，然后运行即可","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"python-基础语法2","slug":"python-基础语法2","date":"2019-01-26T02:04:52.000Z","updated":"2019-09-03T09:30:07.545Z","comments":true,"path":"2019/01/26/python-基础语法2/","link":"","permalink":"http://yoursite.com/2019/01/26/python-基础语法2/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86607838 目录 模块列表 列表的基本操作 列表的循环遍历 元组 元组的基本操作 元组的循环遍历 元组的应用场景 元组和列表之间的转换 字典 字典的常用操作 字典的循环遍历 字典的使用场景 字符串 字符串的常用操作 字符串的方法 公共方法 max(item) 返回容器中元素最大值 如果是字典，只针对key比较 min(item) 返回容器中元素最小值 如果是字典，只针对key比较 切片 成员运算符 完整的for循环语法 模块 模块就好比是工具包，要想使用这个工具包中的工具，就需要导入import这个模块 每一个以扩展名.py结尾的python源代码文件都是一个模块 在模块中定义的全局变量、函数都是模块能够提供给外界直接使用的工具 使用模块 在一个python文件中定义变量或者函数 在另外一个文件汇总使用 import 导入这个模块 使用 模块名.变量 / 模块名.函数 的方式使用这个模块中定义的变量或函数 列表 List（列表）是Python中使用最频繁的数据类型，在其他语言通常叫数组 专门用于存储一串信息（通常是相同类型的数据） 用 [] 定义，数据之间使用 , 分隔 列表的索引从 0 开始，索引就是位置标号，又称下标 列表的基本操作 序号 | 分类 | 关键字/函数/方法 | 说明 -- | -- | ----------------------- | ------------ 1 | 增加 | 列表名.insert(索引，数据) | 在指定位置插入数据 | | 列表I名.append(数据) | 在末尾插入数据 | | 列表名.extend(列表2） | 将列表2的数据追加到列表 2 | 修改 | 列表名[索引] = 数据 | 修改指定索引的数据 3 | 删除 | del 列表名[索引] | 删除指定索引的数据 | | 列表.remove[数据] | 删除第一个出现的指定数据 | | 列表.pop | 删除末尾的数据 | | 列表.pop[索引] | 删除指定索引数据 | | 列表.clear | 清空列表 4 | 统计 | len(列表) | 列表长度 | | 列表.count(数据) | 数据在列表中出现的次数 5 | 排序 | 列表.sort() | 升序排序 | | 列表.sort(reverse = True) | 降序排序 | | 列表.reverse() | 逆序、翻转 列表的循环遍历 遍历就是从头到尾一次从列表中获取数据，在循环体内部针对每一个元素，执行相同的操作 在python中，为了提高列表的遍历效率，专门提供的迭代遍历 使用 for 循环内部使用的变量 in 列表： 来遍历 元组 Tuple(元组) 与列表类似，不同之处在于元组的元素不能修改，元组表示多个元组组成的序列 用于存储一串信息，数据之间使用 ， 分隔（通常是不同类型的数据） 元组用 （） 定义 元组的 索引从 0 开始 元组的基本操作 序号 | 分类 | 关键字/函数/方法 | 说明 -- | --- | ------------- | --------- 1 | 统计 | 元组名.count(数据) | 统计指定数据的个数 | | len(元组名) | 统计元组的长度 2 | 取索引 | 元组名.index(数据) | 获取数据的位置 元组的循环遍历 跟列表一样，使用 for 循环内部使用的变量 in 元组：来遍历元组 可以遍历所有非数字类型的变量：列表、元组、字典以及字符串 在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历的需求并不是很多 元组的应用场景 函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据 格式化字符串 让列表不可以被修改，以保护数据安全 元组和列表之间的转换 使用list函数把元组转换成列表 1list(元组) 使用tuple函数把里列表转换成元组 1tuple(列表) # 字典 除列表以外最灵活的数据类型 通常用于存储描述一个物体的相关信息 和列表的区别是：列表是有序的对象集合，字典是无序的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 ， 分隔 键 key 是索引 值 value 是数据 键和值之间使用 ： 分隔 键必须是唯一的 值可以取任何数据类型，键只可以使用字符串、数字或元组# 字典的常用操作类型 | 语法 | 说明 ----- | --------------- | --------------------------------- 取值 | 字典名[键] | 取字典中指定键的值 增加/修改 | 字典名[键] = 值 | 对字典中指定键的值修改或增加 删除 | 字典名.pop(键) | 删除字典中指定键的值 统计 | len(字典名) | 统计字典中键值对的数量 合并 | 字典1.update(字典2) | 把字典2的键值对合并到字典1，如果有相同的键值对，则会覆盖字典1的 清空 | 字典名.clear() | 清空字典所有键值对 字典的循环遍历 使用 for 循环内部使用的 “key” 的变量 in 字典：来获取字典中的键值对 123456 xiaoming_dict = &#123; &quot;name&quot; ： &quot;小明&quot;, &quot;age&quot; : &quot;18&quot; &#125;for k in xiaoming_dict: for(&quot;%s - %s&quot; % (k,xiaoming_dict[k])) 由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 字典的使用场景 使用多个键值对存储描述一个物体的相关信息——描述更复杂的数据信息 将多个字典放在一个列表中，再进行遍历，在循环体内部针对每一个字典进行相同的处理 字符串 一串字符，是表示文本的数据类型 使用一对双引号 ” 或者一对单引号 ‘’ 来定义一个字符串 可以使用&quot; 或 \\’ 来进行字符串的转义，但实际开发中 如果字符串内部使用“”，可以使用 ‘’ 来定义字符串 如果字符串内部使用‘’，可以使用 “” 来定义字符串 使用索引来获取一个字符串中指定位置的字符，索引从0开始 可以使用 for in 循环遍历 字符串的常用操作 类型 | 语法 | 说明 -- | -------------- | -------------- 统计 | len(字符串名) | 统计字符串的长度 | 字符串名.count(字符) | 统计字符在字符串中出现的次数 查看 | 字符串名.index(字符) | 查看指定字符在字符串中的位置字符串的方法 判断类型 查找和替换 大小写转换 文本对齐 去除空白字符 拆分和连接 公共方法函数 | 描述 | 备注 --------- | ---------- | -------------- len(item) | 计算容器中元素个数 | del(item) | 删除变量 | del有两种方式 max(item) | 返回容器中元素最大值 | 如果是字典，只针对key比较 min(item) | 返回容器中元素最小值 | 如果是字典，只针对key比较# # 切片 切片 使用 索引值 来限定范围，从一个大的字符串中切出小的字符串 列表 和 元组 都是 有序 的集合，都能够通过索引值获取到对应的数据 字典 是一个 无序 的集合，是使用键值对保存数据 成员运算符运算符 | 描述 ------ | ------------------------------ in | 如果在指定的序列中找到值返回True,否则返回False not in | 如果在指定的序列中没有找到值返回True,否则返回False完整的for循环语法 语法 1234 for 变量 in 集合: 循环体代码else: 没有通过break退出循环 ，循环结束后，会执行的代码 应用场景 在迭代遍历嵌套的数据类型是，例如一个列表包含了多个字典 需求：判断某一个字典中是否有指定的值 如果存在，提示并退出循环 如果不存在，在循环整体结束后，希望得到一个统一的提示","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Python-第一个程序","slug":"Python-第一个程序","date":"2019-01-19T12:29:28.000Z","updated":"2019-09-03T09:30:04.829Z","comments":true,"path":"2019/01/19/Python-第一个程序/","link":"","permalink":"http://yoursite.com/2019/01/19/Python-第一个程序/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86533041 源程序的基本概念 源程序就是一个文本文件，所以可以使用任何的文本编辑器做Python的开发 Python程序的文件扩展名通常都是.py 把以下代码复制到一个文本文件中，然后命名为后缀为.py的文件，在命令行找到文件的目录，使用python+程序文件名.py 命令来运行文件 12 print(&quot;Hello world&quot;)print(&quot;Welcome to shareclub&quot;) 编程中常见错误 一行代码写多条语句：这是错误的，因为Python是解析语言，代码时一行一行执行下来的，所以，建议不要把多条语句写在同一行，如果真的需要的话，则在多个语句间加 \\n 缩进错误：Python语言有优雅的特性，所以，具有严格的代码缩进检查，如果缩进不正确，就会报错，程序无法执行 python 2.x 默认不支持中文：Python 3.x 才支持中文，所以使用python 3.x 的解析器才能运行含有中文的程序， Python 2.x 的解析器名称是python，Python 3.x的解析器的名称是python3 Python 2.x 与 3.x 版本简介 python 2.x 是过去的版本，python 3.x 是现在和未来的版本，所以现在学习就学习3.x版本的 python 3.x 是不向下兼容的，早期版本的python程序，是无法用python3解析器执行的 为了照顾现有的程序，官方发布了一个过渡版本——python 2.6，但是python 2.7被确定为为2.x的最后一个版本总结：建议最新开发的程序直接使用python 3.0 来开发，但如果遇到不兼容的第三方库，则先使用Python 3.0 版本进行开发，然后使用python 2.6 、 python 2.7 来执行，然后做一些兼容性的处理 执行Python的方式 1. 解析器python/python312345 #使用python 2.x 解析器$ python xxx.py#使用python 3.x 解析器$ python3 xxx.py 其他解析器（因为Python解析器很多都是由c等其他语言编写的） Cpython——C语言实现的 Jython——可以运行在java平台的 IronPython——可以运行在.NET和Mono平台的（这个我不太了解） PyPy——Python实现的（对，就是自己实现自己） 2. 交互式运行Python程序 直接在终端中运行解析器，不输入执行的文件名,在终端直接使用python 或 python 3就能打开解析器，运行后可以看到对应的版本号 直接在python的shell中输入python的代码，立即看到程序执行的结果 优点：适合学习、验证python语法和局部代码 缺点：代码不保存，不适合太大的程序 退出解析器命令 exit() 或者ctrl + d 除了使用默认的shell，还可以使用一个更强大的shell : IPython 比默认的shell好用，它有什么特性呢? 支持自动补全 自动缩进 支持bash shell 命令（linux） 内置许多很有用的功能和函数 运行方法也是直接在终端中输入 ipython 命令打开解析器，退出直接输入 exit 或 Ctrl + d 就可以了 3. 集成开发环境（IDE）——PyCharm 集成开发环境（IDE, Integrated Development Envionment）——集成了开发软件需要的所有工具 图形用户界面 代码编辑器 编译器/解析器 调试器（断点/单步） … PyCharm介绍 可在Windows、Linux、macOS下使用 适合大型项目 对于PyCharm的安装和使用我在这就不整理出来的，可以自己去百度谷歌一下","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Python-简介","slug":"Python-简介","date":"2019-01-17T15:29:37.000Z","updated":"2019-09-03T09:30:10.795Z","comments":true,"path":"2019/01/17/Python-简介/","link":"","permalink":"http://yoursite.com/2019/01/17/Python-简介/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86532850 创始人 吉多-范罗苏姆（Guido van Rossum） 起名 Python (蟒蛇） 解释器和编译器的区别 计算机只能识别机器语言，所以程序员所写的程序语言翻译成机器语言，计算机才能执行程序。这个翻译的工具就是编译器。 编译器翻译有两种方式：一种是编译，另外一种是解释。 编译是把程序通过编译器全部翻译成机器语言，形成可执行文件，直接双击运行就可以了，优点是执行速度快，缺点是跨平台性差 解释是把程序的代码逐个翻译然后执行，重复这个过程，优点是跨平台性好，缺点是执行速度并编译慢 设计目标 简单直观，且与主要竞争者一样强大 开源 可阅读性强 适用于短期开发的任务 设计哲学 优雅 明确 简单 用一种方法，最好只有一种方法来做一件事 面临多种选择，拒绝花哨语法，选择明确而少歧义的语法 特性 代码量少 开发速度快 完全面向对象 拥有一个强大的标准库 开源社区提供了大量第三方模块","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"数据结构-2算法和时间复杂度","slug":"数据结构-2算法和时间复杂度","date":"2019-01-16T03:00:46.000Z","updated":"2019-09-03T06:58:10.018Z","comments":true,"path":"2019/01/16/数据结构-2算法和时间复杂度/","link":"","permalink":"http://yoursite.com/2019/01/16/数据结构-2算法和时间复杂度/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86427857 什么是算法？ 对问题求解步骤的描述，通过有限序列的指令来实现 特征： 有穷性：有限，不重复循环 确定性：每个步骤都是明确无歧义的 可行性：计算机能实现的算法 输入：被计算机处理的各种类型数据 输出：计算机处理后输出的结果 算法的复杂度时间复杂度 用于衡量当问题规模不断增大，算法执行时间增长的快慢。记作T(n)，则时间复杂度主要分析T(n)的数量级。T(n)=O(f(n))，大O记法，f(n)是算法中基本运算的频度，一般考虑最坏情况下的时间复杂度 计算方法：取算法中时间增长最快的那个函数项，把它的系数改为1 空间复杂度 用于衡量算法随着问题规模增大，算法所需空间的增长的快慢，S(n)=O(g(n))。 时间复杂度大小关系： O(1)&lt;O(log2n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n) 从左至右，时间性能依次降低 复杂度的计算时间复杂度： 复杂度是关于增长率的，所以直接忽略常数项，只关注问题规模 一般可以直接关注循环段基本操作语句的执行次数 1)单个循环体： 直接关注循环体的执行次数 2)多个循环体： 运算规则：乘法规则，加法规则 两个循环体是独立的，采用加法规则：T(n)=T1(n)+T2(n)=max(T1(n),T2(n)) 两个循环体是嵌套的，采用乘法规则：T(n)=T1(n)*T2(n) 空间复杂度： 算法运算过程中使用的辅助空间的大小 S(n)=O(f(n))","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"数据结构-1基本概念","slug":"数据结构-1基本概念","date":"2019-01-13T09:50:56.000Z","updated":"2019-09-03T06:58:02.149Z","comments":true,"path":"2019/01/13/数据结构-1基本概念/","link":"","permalink":"http://yoursite.com/2019/01/13/数据结构-1基本概念/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86425570 基本概念数据： 数据是信息的载体，描述某个事物属性的数字、字符以及能够输入到计算机被程序识别和处理的符号集合。 数据元素： 数据的基本单位，一个数据元素由若干个数据项组成，例：学生是一个数据元素，由学号，姓名，性别等数据项组成。 数据类型： 1）原子类型：值不可再分的数据类型 2）结构类型：值可在分解若干成分 3）抽象数据类型（ADT）：抽象出数据组织和与之对应的操作，三元组（数据对象，数据关系，基本操作集） 数据结构： 相互之间存在一种或多种特定关系的数据元素的集合，包括逻辑结构，存储结构 1）逻辑结构：数据元素之间的逻辑关系，与存储无关，包括线性结构、非线性结构 集合：只有一个关系“同属一个集合” 线性结构：一对一关系 树形结构：一对多关系 图状结构或网状结构：多对多关系 2）物理（存储）结构：数据结构在计算机中的表示 顺序存储：存储位置相邻 链式存储：物理位置未必相邻，记录相邻元素的物理位置来找到相邻元素 引存储索：类似目录 散列存储：通过关键字计算出元素的物理地址 数据的运算：运算的定义和实现","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"ROS入门（2）roslaunch的使用","slug":"ROS入门（2）roslaunch的使用","date":"2019-01-11T03:53:28.000Z","updated":"2019-09-03T09:30:52.952Z","comments":true,"path":"2019/01/11/ROS入门（2）roslaunch的使用/","link":"","permalink":"http://yoursite.com/2019/01/11/ROS入门（2）roslaunch的使用/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86293893 1、什么是roslaunch roslaunch可以用来启动定义在launch文件中的多个节点 2、使用roslaunch roslaunch需要在程序包中使用，所以需要进入你创建的程序包中，还没创建工作区和程序包可根据我上一篇文章创建ROS入门（2）创建工作区、程序包 1）进入程序包目录1$ roscd beginner_tutorials 2）创建launch文件夹12 $ mkdir launch$ cd launch 3）在launch文件夹中创建名为turtlemimic.launch文件（路径在/home/catkin_ws/src/beginner_tutorials/launch），并把下面代码粘贴到文件中12345678910111213141516 &lt;launch&gt; &lt;group ns=&quot;turtlesim1&quot;&gt; &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt; &lt;/group&gt; &lt;group ns=&quot;turtlesim2&quot;&gt; &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt; &lt;/group&gt; &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt; &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt; &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt; &lt;/node&gt; &lt;/launch&gt; 4）启动launch文件1$ roslaunch beginner_tutorials turtlemimic.launch 运行后就会启动两个turtlesim","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"ROS入门","slug":"ROS入门","permalink":"http://yoursite.com/tags/ROS入门/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"ROS入门（2）创建工作区、程序包","slug":"ROS入门（2）创建工作区、程序包","date":"2019-01-11T02:47:21.000Z","updated":"2019-09-03T09:30:43.571Z","comments":true,"path":"2019/01/11/ROS入门（2）创建工作区、程序包/","link":"","permalink":"http://yoursite.com/2019/01/11/ROS入门（2）创建工作区、程序包/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86290128 1、什么是工作空间 工作空间时存放工作项目开发相关文件的文件夹 src：代码空间（source space） build：编译空间（build space） devel：开发空间（development space） install：安装空间（install space） 2、创建步骤1）创建工作空间1$ mkdir -p ~/catkin_ws/src 2）编译空间 这个工作空间还是空的，但我们还是可以编译它 12 $ cd ~/catkin_ws/$ catkin_make 这时候，catkin_ws目录中就会多了“build”和“devel”两个文件夹，src中也出现了一个CMakeList.txt文件 3）配置工作环境1$ source devel/setup.bash 这样子只能在当前终端生效，所以我们可以通过修改/.bashrc文件来配置环境变量，使用vi或gedit打开/.bashrc 1$ gedit ~/.bashrc 将如下语句添加到文末，保存退出 12 $ source opt/ros/kinetic/setup.bash$ source ~/catkin_ws/devel/setup.bash 在终端让其生效 1$ source ~/.bashrc 4）测试工作环境变量1$ echo $ROS_PACKAGE_PATH 输出结果如下，则配置成功 1/home/shareclub/catkin_ws/src:/opt/ros/kinetic/share 3、什么是ROS程序包 程序包是ROS中组织软件的主要形式，可以编写代码并进行编译、执行等操作，相当于一个project。一个程序包一般包含程序文件（src文件夹中的.cpp和.py文件）、编译描述文件（package.xml）和配置文件（CMakeList.txt）等。 4、创建程序包 程序包存放的路径都是在src文件目录中，所以先进去src中，然后通过catkin_create_pkg创建程序包，语法结构是： 123 $ cd ~/catkin_ws/src$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp//语法结构：catkin_create_pkg 包名称 依赖1 依赖2 依赖3 执行完后，就会在src中多了一个beginner_tutorials文件夹和CMakeList.txt文件，当然也可以自己自定义程序包，这里就不说了 5、编译程序包 回到工作区目录 1$ cd ~/catkin_ws/ 如果只编译一个程序包则 12 $ catkin_make beginner_tutorials//语法结构：catkin_make 包名称 如果编译整个工程 1$ catkin_make","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"ROS入门","slug":"ROS入门","permalink":"http://yoursite.com/tags/ROS入门/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"2018总结及2019计划","slug":"2018总结及2019计划","date":"2019-01-10T03:06:12.000Z","updated":"2019-09-03T06:55:37.025Z","comments":true,"path":"2019/01/10/2018总结及2019计划/","link":"","permalink":"http://yoursite.com/2019/01/10/2018总结及2019计划/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/86218381 2018年完成任务： 1、拿到了驾驶证：考证过程十分顺利，约考成功也比其他人的快很多，然后考试都是一次性过，所以寒暑假就把驾驶证搞定了，这个值得开心的。 2、拿到了奖学金：今年拿到了三等奖学金，虽然不是很高等级，但也很高兴，下一年继续好好学习，努力争取下一年的奖学金。 3、加入了ROS机器人团队：当时老师发布通知招收学生组建团队，自己对其感兴趣就积极主动地找同学组队参加，加入后也学习到了很多新鲜的知识，为自己主动抓住机会而感谢自己。 4、坚持健身：很庆幸这一年能够坚持健身，身体是革命本钱。 2018不足之处： 1、犹豫不决：许多时候行事不够果断，错失了许多机会。 2、执行力不足：制定了很多计划，但总是半途而废。 3、易感染：IT是个多元化的领域，众多的技术有人说好有人说坏，容易受到其他人的观点而修改自己已定下的目标 2019年关键词： 行动、思考 目标： 1、掌握nodejs 2、学习ROS 3、扎实计算机基础 考证： 1、普通话证：虽然好像对于一个程序员来说不是很有用，但就是想要去考一下。 2、六级争取高分：虽然已经通过了六级，但是觉得分数还是不够高，再考一次，希望获取更高的成绩 2019年要敢于探索从未涉足过的领域，全面发展自我，同时学会高效率，高回报地投资自我。要沉下来，踏实做自己的事情。Don’t talk, just do it! 经过深思熟虑后，我决定加入2020考研大军，为自己的人生再增添一种色彩。目前已经进入备考状态，所以都比较忙。很感谢你们来阅读我的文章，也感谢你们给我留言，每次看到自己写的文章有那么多人来看都很开心。无论你们是学生、还是工作的，我希望我们能够一起加油，为自己的梦想而奋斗，为自己的人生而拼搏。","categories":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/categories/程序人生/"}],"tags":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/tags/程序人生/"}],"keywords":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/categories/程序人生/"}]},{"title":"java程序运行后不退出","slug":"java程序运行后不退出","date":"2018-12-11T14:05:22.000Z","updated":"2019-09-03T09:28:25.786Z","comments":true,"path":"2018/12/11/java程序运行后不退出/","link":"","permalink":"http://yoursite.com/2018/12/11/java程序运行后不退出/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84962676 在main中的最后加入以下代码 123456 System.out.println(&quot;\\n是否退出程序：Y/N&quot;);Scanner input = new Scanner(System.in);String Y_N = input.nextLine();if(Y_N.equals(&apos;Y&apos;)||Y_N.equals(&apos;y&apos;))&#123; System.exit(0);&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Windows Server 2003 Enterprise Edition 下载与安装序列号","slug":"Windows Server 2003 Enterprise Edition 下载与安装序列号","date":"2018-12-05T01:28:22.000Z","updated":"2019-09-03T09:32:14.669Z","comments":true,"path":"2018/12/05/Windows Server 2003 Enterprise Edition 下载与安装序列号/","link":"","permalink":"http://yoursite.com/2018/12/05/Windows Server 2003 Enterprise Edition 下载与安装序列号/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84818200 提供百度云盘下载链接 http://pan.baidu.com/s/1pKL9pwf 序列号： MPQ6X-3MCCF-47H9T-TKC2F-T69WM FGJCG-8Q883-MQPRF-W8FDB-QPV3Y GGH24-F94R6-XJPR9-FW9XQ-DBDHM BRKX3-BB88X-GP7VW-HYQJR-C7QHM HYDGJ-3WY89-YJB68-H2DV2-BYT7M BPQBT-4MTVT-CDQGB-BGVFP-MK8YB FWRB6-WVPJW-HB6Q7-2MTYK-M8BQY PR86X-KWMQK-6CJVG-RCXFX-WWKWM PGCFX-RGRGX-VFHRX-WT6TJ-QVFFY F8QV3-BTYMR-V4GHX-B43FM-DY6CB MXC6T-JW7WQ-DY7H3-F8JV7-V9XWM DR7QV-WQDC8-G4DP9-9TY2P-Y9CPB HWX9H-KVPMC-3W2DJ-P2392-K9G8M","categories":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}],"tags":[{"name":"window server","slug":"window-server","permalink":"http://yoursite.com/tags/window-server/"}],"keywords":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}]},{"title":"Win10装双系统Ubuntu16.04+EasyBCD","slug":"Win10装双系统Ubuntu16.04+EasyBCD","date":"2018-11-30T15:30:01.000Z","updated":"2019-09-03T09:32:04.127Z","comments":true,"path":"2018/11/30/Win10装双系统Ubuntu16.04+EasyBCD/","link":"","permalink":"http://yoursite.com/2018/11/30/Win10装双系统Ubuntu16.04+EasyBCD/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84576199 最近需要搞一个机器人项目，使用的是ROS机器系统，而这个系统需要安装在linux系统上，所以就要安装个linux系统。思考了一下，用虚拟机虽然简单方便，但速度太慢，而且不稳定，然后就想装个双系统吧。 参考自：https://blog.csdn.net/yucicheung/article/details/72844727 工具： 1.Ubuntu 16.04.5 LTS (Xenial Xerus) 2.EasyBCD 3.分区助手 教程： 1.windows硬盘分区 2.EasyBCD设置NeoGrub引导 3.Ubuntu16.04安装 4.利用EasyEasyBCD引导Ubuntu启动 1.windows硬盘分区 分区就是为了给Ubuntu系统一个空闲的空间，所以需要压缩卷腾出一个大约是50G-100G的空间，至于多少，由你自己的硬盘大小而定，我就设置了100G的（注意：压缩卷后显示未分配即可，不需新建简单卷），我这里使用的是分区助手，也可以右击电脑标志，选择管理-&gt;磁盘管理，然后分区 2.EasyBCD设置NeoGrub引导 下载好EasyBCD后，直接解压安装打开即可，个人使用是免费的。选择添加新条目，右边选择NeoGrub,点击“安装” 安装完成后，会在C盘目录下创建一个名为“NeoGrub”的文件。 点击配置，然后把下面文本复制到NeoGrub文件中的后面 1234 title Install Ubunturoot (hd0,0)kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.1-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8initrd (hd0,0)/initrd.lz （hd0,0） 这里代表的是C盘的位置，hd0表示磁盘的序号，后面的0代表该磁盘上由左往右（从0开始）C盘分区所在的位置。 filename=/后面跟你下载的iso文件名，我的是 ubuntu-16.04.1-desktop-amd64.iso 配置好后，保存退出即可 将一开始下载的Ubuntu镜像文件复制到c盘根目录下，然后打开镜像文件，把casper文件夹打开，然后将其中的文件“initrd.lz” 和 “vmlinuz.efi” 拷贝到c盘根目录下 最后c盘目录下多出来的文件如下，这样做就是从c盘引导安装 准备工作都做好后，接下来就可以重启电脑进行Ubuntu安装了 ## 3.Ubuntu16.04安装 重启后，需要点时间，然后就会出现“NeoGrub引导加载器” 点击后，可以看见“Install Ubuntu” 点击后，进入Ubuntu桌面，左上角有个“安装Ubuntu16.04LTS”程序 点击图标后，进行语言选择，到最后选择“中文（简体）” 下一步，勾选第二项，可以省去很多配置步骤 下一步，“安装类型”，选择“其他选项”，自己来分配硬盘分区 分区过程（非常非常非常重要） 选择之前分出来的空闲的空间，点击左下角“+”号，按下面的方案进行分区（当然分区方式有很多种，之前我就尝试了其他的安装教程，他们的分区方式就跟这个不一样，不过按下面的方案就可以了） 注意：按参考资料分区会有个错误，就是分了主分区后，空闲空间就变得不可用了，上网百度有的人认为先“主分区“后”逻辑分区“，但我这样做的话确实是出错的，不过先”逻辑分区“后”主分区“却是可以的，所以如果你的电脑也出错了可以使用后者方案。 /home 可以用剩余的空间减去 / 分区的空间得到，当然分区大小只是估算的，不用那么准确的，大概就可以了。 挂载点 | 分区大小 | 新分区类型 | 新分区位置 | 用于 ----- | ------ | ----- | ------ | ---------- 不设置 | 2048M | 逻辑分区 | 空间起始位置 | 交换空间 /boot | 800M | 逻辑分区 | 空间起始位置 | EXT4日志文件系统 /home | 剩余所有 | 逻辑分区 | 空间起始位置 | EXT4日志文件系统 / | 22000M | 逻辑分区 | 空间起始位置 | EXT4日志文件系统## ## ## ## ## 设置好后，将”安装启动引导器的设备“改变为”/boot”所在的设备 注意：在安装之前，打开终端（快捷键Ctrl+Alt+T），输入sudo umount -l /isodevice，将该挂载点卸载，然后再重装。 点击“现在安装”，选择位置“shanghai” 选择“键盘布局” 填写“信息”用户名和密码就是你登陆电脑用的，所以要记住 继续后开始安装 安装完成后重启，进入的是windows系统，下面设置引导 4.利用EasyEasyBCD引导Ubuntu启动 打开EasyBCD，点击添加新条目，选择Linux/BSD 这时候在启动引导项中会多了一项启动Ubuntu系统的条目，默认就是开机时不手动设置就自动选择默认系统，看自己哪个比较常用的，就选哪个吧。 重启后就会看到三个选项，第三个才是安装好的Ubuntu系统 Ubuntu开机选项选择第一个，输入密码就可以进入系统 到这恭喜你已成功安装Ubuntu系统！！！ 感谢源文章的教程，部分图由于安装过程没有截图，故引用源博文的。 出现故障：安装好的Ubuntu系统突然无法启动了（左上角一直有个_闪烁） 原因分析：是引导项出问题了，导致无法找到驱动项 解决方法： 方法一： 1.在编辑引导菜单，把原来的NeoSmart Linux删除 2.在添加新条目，linux/BSD重新添加引导文件，注意驱动器必须是/boot分区（分区/boot是800Mb） 方法二：在BCD备份/修复中执行重新创建/修复引导文件","categories":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}],"tags":[{"name":"win10","slug":"win10","permalink":"http://yoursite.com/tags/win10/"}],"keywords":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}]},{"title":"ROS 入门 （1）","slug":"ROS 入门 （1）","date":"2018-11-28T04:19:29.000Z","updated":"2019-09-03T09:30:40.819Z","comments":true,"path":"2018/11/28/ROS 入门 （1）/","link":"","permalink":"http://yoursite.com/2018/11/28/ROS 入门 （1）/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84578577 ROS简介 ROS(Robot Operating System）是一个机器人软件平台，它能为异质计算机集群提供类似操作系统的功能。 ROS提供一些标准操作系统服务，例如硬件抽象，底层设备控制，常用功能实现，进程间消息以及数据包管理。ROS是基于一种图状架构，从而不同节点的进程能接受，发布，聚合各种信息（例如传感，控制，状态，规划等等）。目前ROS主要支持Ubuntu。 ROS可以分成两层，低层是上面描述的操作系统层，高层则是广大用户群贡献的实现不同功能的各种软件包，例如定位绘图，行动规划，感知，模拟等等。 ROS（低层）使用BSD许可证，所有是开源软件，并能免费用于研究和商业用途。而高层的用户提供的包则可以使用很多种不同的许可证。 ROS是一个机器人系统，它要在Linux系统中才能运行，所以相当于是Linux的次级系统，而ROS对Ubuntu系统的兼容性是最好的，所以一般都安装ROS在Ubuntu中，但是两个的版本是有对应的，一定要按以下规则安装 ROS发布日期 | ROS版本 | 对应的Ubuntu版本 ------- | -------------------- | ----------------------------------- 2016.3 | ROS Kinetic Kame | Ubuntu 16.04(Xenial)/Ubuntu 15.10 2015.3 | ROS Jade Turtle | Ubuntu 15.04(Wily)/Ubuntu LTS 14.04 2014.7 | ROS Indigo Igloo | Ubuntu 14.04(Trusty) 2013.9 | ROS Hydro Medusa | Ubuntu 12.04 LTS(Precise) 2012.12 | ROS Groovy Galapagos | Ubuntu 12.04(Precise) ... | ... | ... # ROS安装配置（本博文使用版本Ubuntu 16.04 + ROS Kinetic)1.软件中心配置 Ubuntu桌面右上角设置-&gt;系统设置-&gt;软件和更新，按下图全部勾选（确保”restricted” “universe” 和 ”multiverse”都勾选了），关闭更新即可 2.添加源 打开控制台（Ctrl + Alt + T ），输入如下指令： 1$ sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos; 设置密钥： 1$ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 0xB01FA116 3.安装ROS 更新系统软件，保证是最新版 1$ sudo apt-get update ROS kinetic有很多版本，工业版，基础版，高级版，豪华版，至尊豪华…学习ROS，当然是安装自尊豪华全功能版本 1$ sudo apt-get install ros-kinetic-desktop-full 打完代码，你就可以进入漫长的等待状态（网速好的可能会快点，可恶的是我一直没搞定Ubuntu连接校园网的问题，只能开着手机wifi，网速最快几百k，最慢达到pb级别…汗颜…然后挂了一个晚上才安装好，幸运的是，安装十分顺利，没有任何小虫子(bug)的骚扰） 安装完成后，使用下面的命令查看可使用的包： 1$ apt-cache search ros-kinetic 4.初始化ROS 初始化rosdep 12 $ sudo rosdep init$ rosdep update 初始化环境变量(非常重要) 12 $ echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc$ source ~/.bashrc 安装常用的插件 1$ sudo apt-get install python-rosinstall 5.测试ROS 启动ROS 1$ roscore 看看有没有显示started core service [/rosout]，有则测试成功，恭喜你！！！ 另外说说： 每次打开终端，都需要初始化环境，然后在启动ROS，会比较麻烦，不过下面的方法可以解决这个问题 6.Ubuntu开机自启动roscore命令，自动打开终端执行脚本命令 新建一个脚本文件，名字为 autoLoad.sh （存放的地方随便，home是你个人文件目录，所以可以放在这里） 把以下代码复制到文件中，ROS版本修改为自己的ROS版本，保存 123 #！ /bin/bashsource /opt/ros/ROS版本/setup.bashroscore 打开终端，执行gnome-session-properties,弹出一个“启动应用程序首选项”的菜单，点击添加 名称、注释随便填 命令：gnome-terminal -X autoLoad所在目录路径/autoLoad.sh 示例：我的autoLoad.sh 路径为 /home/shareclub/Ros/mecAGV/autoLoad.sh 则命令为：gnome-terminal -X /home/shareclub/Ros/mecAGV/autoLoad.sh 点击添加即可 ROS初级使用ROS文件系统介绍 1.文件系统工具 rospack 允许你获取软件包的有关信息，使用rospack中的find参数选项，可以返回软件包的路径信息 用法： 1$ rospack find [包名称] 示例： 1$ rospack find roscpp 输出： 1YOUR_INSTALL_PATH/share/roscpp roscd roscd是rosbash命令集中的一部分，允许你直接切换（cd）工作目录到某个软件包或软件包集中。 用法： 1# roscd [本地包名称[/子目录]] 示例： 1$ roscd roscpp 验证输出： 123 $ pwd//输出 YOUR_INSTALL_PATH/share/roscpp 注意：roscd智能切换到那些路径已经包含在ROS_PACKAGE_PATH环境中的软件包，要查找ROS_PACKAGE_PATH中包含的路径可输入 1$ echo $ROS_PACKAGE_PATH 使用roscd也可以切换到一个软件包或软件包集的子目录中 示例： 12 $ roscd roscpp/cmake$ pwd 输出： 1YOUR_INSTALL_PATH/share/roscpp/cmake roscd log 可以切换到ROS保存日志文件的目录下，需注意的是，如果你没有执行过任何ROS程序，系统会报错说该目录不存在 示例： 12 $ roscd log$ pwd 输出： 1/home/YOUR_NAME/.ros/log rosls rosls是rosbash命令集中的一部分，允许直接按软件包的名称而不是绝对路径执行ls命令 用法： 1# rosls [本地包名称[/子目录]] 示例： 1$ rosls roscpp_tutorials 输出： 1cmake launch package.xml srv Tab自动完成输入 当要输入一个完整的软件包名称时会变得比较繁琐，在之前的例子中roscpp tutorial是相当长的名称，但是，一些ROS工具支持TAB自动完成输入的功能。 示例： 1# roscd roscpp_tut&lt;&lt;现在按TAB键&gt;&gt; 按下TAB键后，命令行中会自动补充剩余部分 1$ roscd turtle 但是，如果有多个软件包有同一个开头，按下TAB键后会罗列出所有以同个开头的ROS软件包，这是，只需在列出来的软件包中在输入有差异的部分再按TAB键就会自动补全 示例：在上一个示例的情况下有多个软件包以turtle开头，当再按TAB键后会罗列出所有yiturtle开头的ROS软件包 1turtle_actionlib/ turtlesim/ turtle tf/ turtle)tf2/ 如果你需要的是第一个软件包则 1$ roscd turtle_a&lt;&lt;再次按TAB键&gt;&gt; 命令行自动补全： 1$ roscd turtle_actionlib","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"ROS入门","slug":"ROS入门","permalink":"http://yoursite.com/tags/ROS入门/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"ECMAScript6入门","slug":"ECMAScript6入门","date":"2018-11-15T16:49:23.000Z","updated":"2019-09-03T09:27:41.398Z","comments":true,"path":"2018/11/16/ECMAScript6入门/","link":"","permalink":"http://yoursite.com/2018/11/16/ECMAScript6入门/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84037467 ECMAScript6入门 首先了解一下ECMAScript6的来源： js的组成部分有哪些？ ECMA DOM BOM 什么是ECMA? ECMA是一种标准，js则是实现者 什么是ECMAScript? 简写ECMA或者ES 目前版本： 低级浏览器：支持ES3.1 高级浏览器：ES5过渡到ES6 ECMA的历史： 1996年 ES1.0 js稳定 Netscape将js提交给ECMA组织，ES正式出现 1998年 ES2.0 正式发布 1999年 ES3.0 被浏览器广泛支持 2007年 ES4.0 过于激进，被废除了 2008年 ES3.1 4.0退化成3.1， 代号 Harmony(和谐) 2009年 ES5.0 ES5正式发布，同时公布JavaScript.next 也就是后来的6.0 2011年 ES5.1 成为了ISO国际标准 2013年.3月 ES6.0 颁布草案 2013年12月 ES6.0 发布草案 2015年 ES6.0 预计发布正式版，同时JavaScript.next指向ES7.0 2018年 ES6.0 ES6比ES5的生成力更强，代码更整洁 兼容性： 目前为止 ES5 ES6支持情况基本凑合 node.js 用的是chrome内核，在node中可以使用ES5 ES6很多特性 ES5和ES6已经逐渐沦为后台语言 在浏览器如何使用？ 需要用到编译工具： babel —— 让我们在当前的项目中随意的使用这些新最新的es6，甚至es7的语法 traceur —— 由Google出的编译器，把ES6语法编译为ES5 gulp webpack npm bootstrap 引导程序，跟css认识的bootstrap不一样 在网页上使用： 方法一：直接在中使用 1234567891011121314 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; let a = 12; alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意：如果浏览器无法编译，则需要在https://github.com/aikar/traceur/tree/master/traceur/src下载traceur.js 和 bootstrap.js两个文件，然后引入到HTML文件中 1234567891011121314151617 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--插入一下代码引用两个js--&gt; &lt;script src=&quot;traceur.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; let a = 12; alert(a); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方法二：在线直接使用——主要用于测试 https://google.github.io/traceur-compiler/demo/repl.html https://babeljs.io/repl/ 方法三：直接在node里面使用 a)但直接用时，需要添加‘use strict’ b)node –harmony_descructuring xxx.js 实例：在webstrom创建一个test.js文件 123 &apos;use strict&apos;;let a = 12;console.log(a); ALT+f12快捷键打开webstrom的终端Terminal 输入node test.js 则可执行 新增功能1、let——定义变量1let a = 12; 特点： 1）let具有块级作用域：只能在{}包起来的代码块中使用，是有局部作用域的，而用var定义的变量无论在什么地方都是全局变量的。 2）let不允许重复声明变量，而var声明的两个相同名的变量是不会报错的，后者会覆盖前者 总结：其实let才是接近其他语言的变量 用处：1）封闭空间变得更简洁 实例1： 1234567891011121314151617181920212223 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; //ES5的写法 (function()&#123; var a = 12; alert(a); &#125;)(); //ES6的写法 &#123; let a = 12; alert(a); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 实例2： 12345678910111213141516171819202122232425262728293031 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;script&gt; window.οnlοad=function()&#123; var aBtn = document.getElementsByTagName(&quot;input&quot;); //ES5封闭函数 // for(var i=0; i&lt;aBtn.length; i++)&#123; // (function(i)&#123; // aBtn[i].onclick = function()&#123; // alert(i); // &#125; // &#125;)(i); // &#125; // &#125;; //ES6封闭函数 for(let i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].onclick = function()&#123; alert(i); &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;aaa&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;bbb&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;ccc&quot;&gt;&lt;/body&gt;&lt;/html&gt; 总结：块级作用域，其实就是匿名函数立即调用 const——定义常量，一旦赋值，就不能被修改12 const a = &quot;shareclub&quot;;a = 12; //报错 注意：const必须给初始值，因为以后再也没法赋值了，所以声明的时候一定要有值，还不能重复声明。 用途：为了防止意外修改变量，比如引入库名，组件名。 ## ${}字符串链接1234 //ES5&apos;abc&apos;+变量名+&apos;ef&apos;//ES6`abc$&#123;变量名&#125;ef` //反双引号，1键前面的按键 解构赋值123 var [a,b,c] = [12,5,101]; //a=12 b=5 c=101var &#123;a,b,c&#125; = &#123;b:5,a:12,c:101&#125; //结合json使用，无论赋值顺序如何，a都等于12 模式匹配： 123 var [a,[b,c],d] = [12,[1,2],4]; //左边与右边模式一样var [&#123;a,e&#125;,[b,c],d] = [&#123;e:&apos;eeee&apos;,a:&apos;aaa&apos;&#125;,[1,2],4]; //与json结合 用途——交互：数据解析 12345 var arr = [&#123;title:&apos;abc&apos;, href:&apos;kkk&apos;, img:&apos;img1&apos;&#125;];var [&#123;title,href,img&#125;]=arr;console.log(title,href,img); //输出结果abc kkk img1 解构赋值给默认值 1var &#123;time=12, id=0&#125;=&#123;&#125;; //time默认为12， id默认为0","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Javascript代码规范","slug":"Javascript代码规范","date":"2018-11-13T03:05:43.000Z","updated":"2019-09-03T09:28:50.212Z","comments":true,"path":"2018/11/13/Javascript代码规范/","link":"","permalink":"http://yoursite.com/2018/11/13/Javascript代码规范/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/84025222 Javascript代码规范变量名 变量名推荐使用驼峰法命名（calmelCase） 1firstName = &quot;shareClub&quot;; 空格与运算符 通常运算符（ = + - * / ）前后需要添加空格 1var x = y + z; 代码缩进 通常用4个空格符号缩进代码块（不要使用tab键，因为在不同的平台可能显示不一致） 123 function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125; 语法规则 简答语句的通用规则：一条语句通常以分号作为结束符。 12345678 var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;];var person = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, age: 50, eyeColor: &quot;blue&quot;&#125;; 复杂语句的通用规则： 将左花括号放在第一行的结尾。 左花括号前添加一空格 将右花括号独立放在一行 不要以分号结束一个复杂的声明 12345678910111213141516 //函数function toCelsius(fahrenheit) &#123; return (5 / 9) * (fahrenheit - 32);&#125;//循环for (i = 0; i &lt; 5; i++) &#123; x += i;&#125;//条件语句if (time &lt; 20) &#123; greeting = &quot;Good day&quot;;&#125; else &#123; greeting = &quot;Good evening&quot;;&#125; 对象规则 对象定义的规则: 将左花括号与类名放在同一行。 冒号与属性值间有个空格。 字符串使用双引号，数字不需要。 最后一个属性-值对后面不要添加逗号。 将右花括号独立放在一行，并以分号作为结束符号。 123456 var person = &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, age: 50, eyeColor: &quot;blue&quot;&#125;; 短的对象代码可以直接写成一行: 1var person = &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;&#125;; 每行代码字符小于 80 为了便于阅读每行字符建议小于数 80 个。 如果一个 JavaScript 语句超过了 80 个字符，建议在 运算符或者逗号（不破坏语义的地方）后换行。 12document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello Runoob.&quot;; 命名规则 一般很多代码语言的命名规则都是类似的，例如: 变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase） 全局变量为大写 (*UPPERCASE *) 常量 (如 PI) 为大写 (*UPPERCASE *) HTML 载入外部 JavaScript 文件 使用简洁的格式载入 JavaScript 文件 ( type 属性不是必须的): 1&lt;script src=&quot;myscript.js&quot;&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript正则表达式","slug":"javascript正则表达式","date":"2018-11-04T17:15:33.000Z","updated":"2019-09-03T09:28:59.200Z","comments":true,"path":"2018/11/05/javascript正则表达式/","link":"","permalink":"http://yoursite.com/2018/11/05/javascript正则表达式/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/83692784 什么是正则表达式 Regular Expression 使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。简单说就是按照某种规则去匹配符合条件的字符串 REGEXPER 正则表达式工具：http://regexper.com 正则表达式基础REGEXP对象 JavaScript通过内置对象RegExp支持正则表达式 有两种方法实例化RegExp对象 字面量: 实例：查找is字符 1var reg = /\\bis\\b/; //无修饰符 1var reg = /\\bis\\b/g; //有修饰符g，代表全文档 构造函数 1var reg = new RegExp(&apos;\\\\bis\\\\b&apos;); //不带修饰符 1var reg = new RegExp(&apos;\\\\bis\\\\b&apos;, &apos;g&apos;); //带修饰符g 修饰符 g：global全文搜索，不添加，搜索到第一个匹配停止 i：ignore case 忽略大小写，默认大小写敏感 m：multiple lines 多行搜索 元字符 正则表达式有两种基本字符类型组成 -原义文本字符 代表单词本来的含义的，例：abc就代表abc字符串 -元字符 在正则表达式中有特殊含义的非字母字符 有：* + ？ $ ^ . | \\ ( ) { } [ ] 注：元字符在不同的地方有不同的定义，比如 [ ^a ] 和 ^a 一个代表 a 取反、一个代表以 a 开始 字符 | 含义 ---- | ----------------- \\\\t | 水平制表符 \\\\v | 垂直制表符 \\\\n | 换行符 \\\\r | 回车符 \\\\0 | 空字符 \\\\f | 换页符 \\\\cX | 与X对应的控制字符（Ctrl+X）字符类 基本字符匹配：一般情况下正则表达式一个字符对应字符串一个字符 例：表达式ab的含义是匹配ab字符 1&apos;abcdefg&apos;.replace(/ab/g, &apos;x&apos;) 字符类匹配： ——使用元字符 [] 来构造一个简单的类 ——这个类是指符合某些特性的对象，一个泛指，而不是特指某个字符 ——表达式 [abc] 把字符 a 或 b 或 c 归为一类，表达式可以匹配这类的字符 例：[abc]的含义是匹配a或b或c，而不是abc整个字符 1&apos;a1b2c3d4&apos;.replace([abc]/g, &apos;X&apos;) 字符类取反 ——使用元字符 ^ 取反 例：[^abc] 的含义是匹配除了a 或 b 或 c 之外的字母 1&apos;a1b2c3d4&apos;.replace([^abc]/g, &apos;X&apos;) 范围类 —— [a-z] 连接两个字符表示从 a 到 z 的任意字符 ——这个闭区间，也就是包含 a 和 z 本身 1&apos;a1b2c3x4z9&apos;.replace(/[a-z]/g, &apos;Q&apos;) 在[] 组成的类内部是可以连写的 例：[a-zA-Z] 表示从 a 到 z 和 从 A 到 Z 的任意字符 1&apos;a1b2c3x4z0AVKDJIOSJ&apos;.replace(/[a-zA-X]/g, &apos;Q&apos;) 特殊情况，如果需要匹配字符 - 时则有需要其他写法 例： [0-9] 代表 0 到 9 的任意字符 1&apos;2016-01-10&apos;.replace(/[0-9]/g, &apos;A&apos;) [0-9-] 代表 0 到 9 的任意字符和 - 字符 1&apos;2018-06-16&apos;.replace(/[0-9-]/g, &apos;A&apos;) 预定义类字符 | 等价类 | 含义 --- | -------------------- | ---------------- . | [^\\\\r\\\\n] | 除了回车符和换行符之外的所有字符 \\\\d | [0-9] | 数字字符 \\\\D | [^0-9] | 非数字字符 \\\\s | [\\\\t\\\\n\\\\x0B\\\\f\\\\r] | 空白符 \\\\S | [^\\\\t\\\\n\\\\x0B\\\\f\\\\r] | 非空白符 \\\\w | [a-zA-Z_0-9] | 单词字符（字母、数字下划线） \\\\W | [^a-zA-Z_0-9] | 非单词字符 实例： 匹配一个 ab + 数字 + 任意字符 的字符串 ab\\d. 边界字符 | 含义 --- | ------ ^ | 以XXX开始 $ | 以XXX结束 \\\\b | 单词边界 \\\\B | 非单词边界 例： 量词 匹配多次出现的字符 字符 | 含义 ----- | --------------- ？ | 出现零次或一次（最多出现一次） + | 出现一次或多次（至少出现一次） * | 出现零次或多次（任意词） {n} | 出现n次 {n,m} | 出现n到m次 {n,} | 至少出现n次 贪婪模式和非贪婪模式 贪婪模式 尽可能多的去匹配 例：\\d{3,6} 匹配的是每6个位一组123456而不是每3个为一组123 和 456 1&apos;12345678&apos;.replace(/\\d&#123;3,6&#125;/g, &apos;X&apos;) 非贪婪模式 \\d{3,6} ？匹配的是每3个为一组123 和 456而不是每6个位一组123456 1&apos;12345678&apos;.replace(/\\d&#123;3,6&#125;?/g, &apos;X&apos;) 分组 使用（）可以达到分组的功能，使量词作用域分组 例：/([a-z]\\d){3}/ 字母和数字的组合出现三次 1&apos;a1b2c3d4&apos;.replace(/([a-z]\\d)&#123;3&#125;/g, &apos;Q&apos;) 或 在分组中使用 | 可以达到或的效果 例：’ByronsperByrCasper’.replace(/Byr(on|Ca)sper/g, ‘x’) 1&apos;ByronsperByrCasper&apos;.replace(/Byr(on|Ca)sper/g, &apos;x&apos;) 反向引用 在分组使用 $ 捕获分组 例：’2016-11-25’.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, ‘$2/$3/$1’) 1&apos;2016-11-25&apos;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g, &apos;$2/$3/$1&apos;) 忽略分组 不希望捕获某些分组，只需要在分组内加上？：就可以了 例：’2016-11-25’.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/g, ‘$2/$3/$1’) 1&apos;2016-11-25&apos;.replace(/(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g, &apos;$2/$3/$1&apos;) 前瞻 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前” 前瞻就是在正则表达式匹配到规则的时候，向前面检查是否符合断言，后顾/后瞻方向相反 注：JavaScript不支持后顾 符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配 名称 | 正则 | 含义 ---- | ----------------- | ------------- 正向前瞻 | exp(?=assert) | 负向前瞻 | exp(?!assert) | 正向后顾 | exp(?&amp;lt;=assert) | Javascript不支持 负向后顾 | exp(?&amp;lt;!assert) | Javascript不支持Js对象属性 g：global全文搜索，不添加，搜索到第一个匹配停止，默认false i：ignore case 忽略大小写，默认大小写敏感,默认false m：multiple lines 多行搜索，默认false l：lastIndex : 是当前表达式匹配内容的最后一个字符的下一个位置 s: source:正则表达式的文本字符串 test方法和exec方法 test方法 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在则返回true,否则返回false exec方法 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null,否则返回一个结果数组： ——index 声明匹配文本的第一个字符的位置 ——input 存放被检索的字符串string 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"webstrom 快速生成代码块","slug":"webstrom 快速生成代码块","date":"2018-11-03T04:00:28.000Z","updated":"2019-09-03T09:31:21.833Z","comments":true,"path":"2018/11/03/webstrom 快速生成代码块/","link":"","permalink":"http://yoursite.com/2018/11/03/webstrom 快速生成代码块/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/83684275 在开发中，有很多模块是重复使用的，但如果每次都要敲一遍，那开发速度就会大大降低，所以，需要自定义一些常用模块代码，然后输入缩写按TAB键输入。下面教教大家如何自定义代码块。 步骤： 1、file-&gt;setting 打开设置面板，Editor-&gt;Live Templates 2、设置快捷书写 3、测试使用 在编辑区输入缩写 按TAB键，则会自动生成","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"webStrom","slug":"webStrom","permalink":"http://yoursite.com/tags/webStrom/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"webstrom 常用的快捷键","slug":"webstrom 常用的快捷键","date":"2018-11-03T01:38:47.000Z","updated":"2019-09-03T09:31:18.634Z","comments":true,"path":"2018/11/03/webstrom 常用的快捷键/","link":"","permalink":"http://yoursite.com/2018/11/03/webstrom 常用的快捷键/","excerpt":"","text":"下面是Webstorm的一些常用快捷键： ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。 ctrl + j: 输出模板 ctrl + b: 跳到变量申明处 ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation) ctrl + []: 匹配 {}[] ctrl + F12: 可以显示当前文件的结构 ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容 ctrl + r: 替换 ctrl + shift + up: 行移动 ctrl + d: 行复制 ctrl + shift + ]/[: 选中块代码 ctrl + / : 单行注释 ctrl + shift + / : 块注释 ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息 ctrl + ‘-/+’: 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。 ctrl + ‘.’: 折叠选中的代码的代码。 ctrl+/ 单行注释 ctrl+shift+/块注释 ctrl+shift+ +/-展开/折叠 ctrl+alt+L 格式化代码 ctrl+shift+ up/down 上下移动句子 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包 Ctrl+E或者Alt+Shift+C 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Shift+Space 自动补全代码 Ctrl+空格 代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名 Ctrl+Shift+先上键 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+J 自动代码 Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 shift + alt + up: 块移动(if(){},while(){}语句块的移动) Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Alt+f12 打开终端terminal界面 Alt+Insert 生成代码(如get,set方法,构造函数等) Alt+回车 导入包,自动修正 alt + left/right:标签切换","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"webStrom","slug":"webStrom","permalink":"http://yoursite.com/tags/webStrom/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"SVG","slug":"SVG","date":"2018-10-27T01:40:49.000Z","updated":"2019-09-03T09:31:07.432Z","comments":true,"path":"2018/10/27/SVG/","link":"","permalink":"http://yoursite.com/2018/10/27/SVG/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/83422474 俗话说得好：最好的学习方法是兴趣引导的学习，在学习SVG之前，先给你们看看一些实例，让你们领略一下SVG的强大，看看能不能激发出你们的学习兴趣。 https://www.html5tricks.com/tag/svg/ 感觉怎么样呢？是不是非常想学习SVG，做一个属于自己的作品出来啊？那就开始学习吧。 目录 SVG入门 SVG简介 位图和矢量图 使用方式 SVG的图形和基本属性 基本图形 基本属性 基本操作API 创建图形 添加图形 设置/获取属性： 通过以上属性制作的svgEditor SVG的坐标系统和坐标变换 SVG的世界、视野、视窗概念 SVG中的图形分组 坐标系统概述 四个坐标系 坐标变换 SVG颜色、渐变和笔刷 RGB和HSL 线性渐变和径向渐变 path高级教程 Path概述 移动和直线命令 弧线命令 贝塞尔曲线 SVG文本 和 创建文本 垂直居中问题 让文本在制定路径上排序 插入超链接 图形的引用、裁切和蒙版 标签创建图形引用 标签裁切图形 标签创建蒙版 SVG动画 动画原理 创造并使用动画 SMIL for SVG SVG入门SVG简介 使用XML描述的矢量文件 位图和矢量图 位图：基于颜色的描述（BMP、PNG、JPG等），图片是像素型，清晰度较低 矢量图：基于数学的描述（SVG、AI等），图片曲线圆滑，清晰度较高 使用方式 浏览器直接打开 SVG矢量图文件后缀为 .svg 在HTML中使用标签引用 12345678910111213 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在HTML中使用img引用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;img src=&quot;SVG.svg&quot;&gt;原始大小&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;SVG.svg&quot; width=&quot;50&quot; height=&quot;50&quot;&gt;50 Ｘ 50&lt;/p&gt; //可直接设置大小 &lt;p&gt;&lt;img src=&quot;SVG.svg&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;400 X 400&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 可爱又机智的笑脸 直接在HTML中使用SVG标签 1234567891011121314151617181920212223 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;smile-SVG&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;!--Face--&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;90&quot; fill=&quot;#39F&quot;/&gt; &lt;!--Eyes--&gt; &lt;circle cx=&quot;70&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&gt; &lt;circle cx=&quot;130&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&gt; &lt;circle cx=&quot;65&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&gt; &lt;circle cx=&quot;125&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&gt; &lt;!--Smile--&gt; &lt;path d=&quot;M 50 140 A 60 60 0 0 0 150 140&quot; stroke=&quot;white&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot;/&gt; &lt;/svg&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 作为CSS背景 1234567891011121314151617181920212223 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;在css使用SVG&lt;/title&gt; &lt;style&gt; body&#123; background-color: #efefef; &#125; #bg&#123; width: 400px; height: 400px; background: white url(&quot;SVG.svg&quot;) repeat; box-shadow:rgba(0,0,0,.5) 2px 3px 10px; border-radius: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello SVG with CSS&lt;/h1&gt; &lt;div id=&quot;bg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; SVG的图形和基本属性基本图形 矩形 x y 横坐标和纵坐标（矩形左上角的位置） width 宽 height 高 rx ry 圆角大小 （只设置rx或ry，则两者的值相同，只有分别设置了不同的值才会各自显示不同的大小） 圆形 cx cy 横坐标和纵坐标（圆形的中心点） r 半径 椭圆 cx cy 横坐标和纵坐标 rx ry 横向半径和纵向半径 线段 x1 y1 端点坐标 x2 y2 端点坐标 折线 points=”x1 y1 x2 y2 x3 y3..” 多少个节点就设置多少个x y 值 . 多边形 points=”x1 y1 x2 y2 x3 y3..” 多少个节点就设置多少个x y 值，第一个节点和最后一个节点会自动连接在一起 基本属性 fill = “#FFB3AE” 填充颜色 stroke = #971817 描边颜色 stroke-width = 10 描边的粗细 transform = “rotate(30)” 旋转变形 基本操作API创建图形 document.createElementNS(ns, tagName) ns是必须设置的，因为svg是单独的xml文件，在html中没有svg的命名空间。tagName指的是基本图形cicle line等 添加图形 element.appendChild(childElement) 设置/获取属性： element.setAttribute(name, value) element.getAttribute(name) 通过以上属性制作的svgEditor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225 &lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;SVG 编辑器&lt;/title&gt; &lt;style&gt; #toolbox &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 250px; border-right: 1px solid #CCC; &#125; #toolbox h2 &#123; margin: 0; padding: 0; background: #EEE; font-size: 16px; height: 24px; line-height: 24px; padding: 5px 10px; &#125; #toolbox form &#123; padding: 10px; &#125; #canvas &#123; position: absolute; left: 260px; top: 10px; bottom: 10px; right: 10px; box-shadow: 2px 2px 10px rgba(0,0,0,.4); border-radius: 5px; &#125; label &#123; display: inline-block; width: 80px; text-align: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;toolbox&quot;&gt; &lt;h2&gt;创建&lt;/h2&gt; &lt;form id=&quot;create-shape&quot;&gt; &lt;button type=&quot;button&quot; create=&quot;rect&quot;&gt;Rect&lt;/button&gt; &lt;button type=&quot;button&quot; create=&quot;circle&quot;&gt;Circle&lt;/button&gt; &lt;button type=&quot;button&quot; create=&quot;ellipse&quot;&gt;Ellipse&lt;/button&gt; &lt;button type=&quot;button&quot; create=&quot;line&quot;&gt;Line&lt;/button&gt; &lt;/form&gt; &lt;h2&gt;形状&lt;/h2&gt; &lt;form id=&quot;shape-attrs&quot;&gt; 请先创建图形 &lt;/form&gt; &lt;h2&gt;外观和变换&lt;/h2&gt; &lt;form id=&quot;look-and-transform&quot; disabled=&quot;disabled&quot;&gt; &lt;p&gt; &lt;label style=&quot;display: inline;&quot;&gt;填充&lt;/label&gt; &lt;input id=&quot;fill&quot; type=&quot;color&quot; value=&quot;#ffffff&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label style=&quot;display: inline;&quot;&gt;描边&lt;/label&gt; &lt;input id=&quot;stroke&quot; type=&quot;color&quot; value=&quot;#ff0000&quot; /&gt; &lt;input id=&quot;strokeWidth&quot; type=&quot;range&quot; value=&quot;1&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;translateX&lt;/label&gt; &lt;input id=&quot;translateX&quot; type=&quot;range&quot; min=&quot;-400&quot; max=&quot;400&quot; value=&quot;0&quot; /&gt; &lt;label&gt;translateY&lt;/label&gt; &lt;input id=&quot;translateY&quot; type=&quot;range&quot; min=&quot;-400&quot; max=&quot;400&quot; value=&quot;0&quot; /&gt; &lt;label&gt;rotate&lt;/label&gt; &lt;input id=&quot;rotate&quot; type=&quot;range&quot; min=&quot;-180&quot; max=&quot;180&quot; value=&quot;0&quot; /&gt; &lt;label&gt;scale&lt;/label&gt; &lt;input id=&quot;scale&quot; type=&quot;range&quot; min=&quot;-1&quot; max=&quot;2&quot; step=&quot;0.01&quot; value=&quot;1&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;div id=&quot;canvas&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var SVG_NS = &apos;http://www.w3.org/2000/svg&apos;; // 图形及对应默认属性 var shapeInfo = &#123; rect: &apos;x:10,y:10,width:200,height:100,rx:0,ry:0&apos;, circle: &apos;cx:200,cy:200,r:50&apos;, ellipse: &apos;cx:200,cy:200,rx:80,ry:30&apos;, line: &apos;x1:10,y1:10,x2:100,y2:100&apos; &#125;; // 默认公共属性 var defaultAttrs = &#123; fill: &apos;#ffffff&apos;, stroke: &apos;#ff0000&apos; &#125;; var createForm = document.getElementById(&apos;create-shape&apos;); var attrForm = document.getElementById(&apos;shape-attrs&apos;); var lookForm = document.getElementById(&apos;look-and-transform&apos;); var svg = createSVG(); var selected = null; createForm.addEventListener(&apos;click&apos;, function(e) &#123; if (e.target.tagName.toLowerCase() == &apos;button&apos;) &#123; create(e.target.getAttribute(&apos;create&apos;)); &#125; &#125;); attrForm.addEventListener(&apos;input&apos;, function(e) &#123; if (e.target.tagName.toLowerCase() != &apos;input&apos;) return; var handle = e.target; selected.setAttribute(handle.name, handle.value); &#125;); lookForm.addEventListener(&apos;input&apos;, function(e) &#123; if (e.target.tagName.toLowerCase() != &apos;input&apos;) return; if (!selected) return; selected.setAttribute(&apos;fill&apos;, fill.value); selected.setAttribute(&apos;stroke&apos;, stroke.value); selected.setAttribute(&apos;stroke-width&apos;, strokeWidth.value); selected.setAttribute(&apos;transform&apos;, encodeTranform(&#123; tx: translateX.value, ty: translateY.value, scale: scale.value, rotate: rotate.value &#125;)); &#125;); function createSVG() &#123; var svg = document.createElementNS(SVG_NS, &apos;svg&apos;); svg.setAttribute(&apos;width&apos;, &apos;100%&apos;); svg.setAttribute(&apos;height&apos;, &apos;100%&apos;); canvas.appendChild(svg); svg.addEventListener(&apos;click&apos;, function(e) &#123; if (e.target.tagName.toLowerCase() in shapeInfo) &#123; select(e.target); &#125; &#125;); return svg; &#125; function create(name) &#123; var shape = document.createElementNS(SVG_NS, name); svg.appendChild(shape); select(shape); &#125; function select(shape) &#123; var attrs = shapeInfo[shape.tagName].split(&apos;,&apos;); var attr, name, value; attrForm.innerHTML = &quot;&quot;; while(attrs.length) &#123; attr = attrs.shift().split(&apos;:&apos;); name = attr[0]; value = shape.getAttribute(name) || attr[1]; createHandle(shape, name, value); shape.setAttribute(name, value); &#125; for (name in defaultAttrs) &#123; value = shape.getAttribute(name) || defaultAttrs[name]; shape.setAttribute(name, value); &#125; selected = shape; updateLookHandle(); &#125; function createHandle(shape, name, value) &#123; var label = document.createElement(&apos;label&apos;); label.textContent = name; var handle = document.createElement(&apos;input&apos;); handle.setAttribute(&apos;name&apos;, name); handle.setAttribute(&apos;type&apos;, &apos;range&apos;); handle.setAttribute(&apos;value&apos;, value); handle.setAttribute(&apos;min&apos;, 0); handle.setAttribute(&apos;max&apos;, 800); attrForm.appendChild(label); attrForm.appendChild(handle); &#125; function updateLookHandle() &#123; fill.value = selected.getAttribute(&apos;fill&apos;); stroke.value = selected.getAttribute(&apos;stroke&apos;); var t = decodeTransform(selected.getAttribute(&apos;transform&apos;)); translateX.value = t ? t.tx : 0; translateY.value = t ? t.ty : 0; rotate.value = t ? t.rotate : 0; scale.value = t ? t.scale : 1; &#125; function decodeTransform(transString) &#123; var match = /translate\\((\\d+),(\\d+)\\)\\srotate\\((\\d+)\\)\\sscale\\((\\d+)\\)/.exec(transString); return match ? &#123; tx: +match[1], ty: +match[2], rotate: +match[3], scale: +match[4] &#125; : null; &#125; function encodeTranform(transObject) &#123; return [&apos;translate(&apos;, transObject.tx, &apos;,&apos;, transObject.ty, &apos;) &apos;, &apos;rotate(&apos;, transObject.rotate, &apos;) &apos;, &apos;scale(&apos;, transObject.scale, &apos;)&apos;].join(&apos;&apos;); &#125;&lt;/script&gt;&lt;/html&gt; SVG的坐标系统和坐标变换SVG的世界、视野、视窗概念 视野（viewBox）是观察世界的一个矩形区域（坐井观天中，井口就是你的视野） 视窗 是浏览器开辟出来的用于渲染SVG的区域 preserveAspectRatio-控制视野（视野和视窗不一致的情况使用） 世界 是SVG定义的，无穷大的 下面是我对三者关系画的图，希望帮助大家理解。 对视野、视窗、还有preserveAspectRatio的属性的使用做出来的实例，大家可在浏览器打开操作一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;ViewBox 使用演示&lt;/title&gt; &lt;style&gt; body &#123; background: #eee; &#125; svg &#123; position: absolute; border: 1px solid green; width: 300px; height: 200px; left: 50%; top: 50%; margin-top: -100px; margin-left: -150px; background: white; &#125; input[type=number] &#123; width: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;ViewBox 演示&lt;/h1&gt; &lt;form id=&quot;form&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;viewBox&lt;/legend&gt; &lt;label&gt;x: &lt;input id=&quot;vx&quot; type=&quot;number&quot; value=&quot;0&quot;&gt;&lt;/label&gt; &lt;label&gt;y: &lt;input id=&quot;vy&quot; type=&quot;number&quot; value=&quot;0&quot;&gt;&lt;/label&gt; &lt;label&gt;width: &lt;input id=&quot;vw&quot; type=&quot;number&quot; value=&quot;300&quot;&gt;&lt;/label&gt; &lt;label&gt;height: &lt;input id=&quot;vh&quot; type=&quot;number&quot; value=&quot;200&quot;&gt;&lt;/label&gt; &lt;/fieldset&gt; &lt;fieldset&gt; &lt;legend&gt;preserveAspectRatio&lt;/legend&gt; &lt;label&gt;align: &lt;select id=&quot;align&quot;&gt; &lt;option value=&quot;none&quot;&gt;none&lt;/option&gt; &lt;option value=&quot;xMinYMin&quot;&gt;xMinYMin&lt;/option&gt; &lt;option value=&quot;xMidYMin&quot;&gt;xMidYMin&lt;/option&gt; &lt;option value=&quot;xMaxYMin&quot;&gt;xMaxYMin&lt;/option&gt; &lt;option value=&quot;xMinYMid&quot;&gt;xMinYMid&lt;/option&gt; &lt;option value=&quot;xMidYMid&quot; selected&gt;xMidYMid&lt;/option&gt; &lt;option value=&quot;xMaxYMid&quot;&gt;xMaxYMid&lt;/option&gt; &lt;option value=&quot;xMinYMax&quot;&gt;xMinYMax&lt;/option&gt; &lt;option value=&quot;xMidYMax&quot;&gt;xMidYMax&lt;/option&gt; &lt;option value=&quot;xMaxYMax&quot;&gt;xMaxYMax&lt;/option&gt; &lt;/select&gt;&lt;/label&gt; &lt;label&gt;meetOrSlice: &lt;select id=&quot;meetOrSlice&quot;&gt; &lt;option value=&quot;meet&quot;&gt;meet&lt;/option&gt; &lt;option value=&quot;slice&quot;&gt;slice&lt;/option&gt; &lt;/select&gt;&lt;/label&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;p&gt; &lt;svg id=&quot;svg&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;!--Face--&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;90&quot; fill=&quot;#39F&quot; /&gt; &lt;!--Eyes--&gt; &lt;circle cx=&quot;70&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot; /&gt; &lt;circle cx=&quot;130&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot; /&gt; &lt;circle cx=&quot;65&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot; /&gt; &lt;circle cx=&quot;125&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&gt; &lt;!--Smile--&gt; &lt;path d=&quot;M 50 140 A 60 60 0 0 0 150 140&quot; stroke=&quot;white&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;rect id=&quot;viewBoxIndicator&quot; stroke=&quot;red&quot; stroke-width=&quot;3.5&quot; fill=&quot;none&quot; /&gt; &lt;/svg&gt; &lt;/p&gt; &lt;script&gt; function update() &#123; var viewBox = [vx.value, vy.value, vw.value, vh.value].join(&apos; &apos;); var preserveAspectRatio = [align.value, meetOrSlice.value].join(&apos; &apos;); svg.setAttribute(&apos;viewBox&apos;, viewBox); svg.setAttribute(&apos;preserveAspectRatio&apos;, preserveAspectRatio); var rect = viewBoxIndicator; rect.setAttribute(&apos;x&apos;, vx.value); rect.setAttribute(&apos;y&apos;, vy.value); rect.setAttribute(&apos;width&apos;, vw.value); rect.setAttribute(&apos;height&apos;, vh.value); &#125; form.addEventListener(&apos;input&apos;, update); update(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; SVG中的图形分组 标签来创建分组 一种整体思维，对多个事物合成分组，然后整体设置其属性 属性继承 transfrom属性定义坐标变换 可以嵌套使用 坐标系统概述 笛卡尔直接坐标系 原点 互相垂直的两条数轴 角度定义：正反向是指顺时针方向 四个坐标系 用户坐标系（User Coordinate）：世界的坐标系，SVG原始坐标系，其他坐标系都是从用户坐标系产生的 自身坐标系（Current Coordinate）：每个图形元素或分组独立与生俱来的 前驱坐标系（Previous Coordinate）：父容器的坐标系 参考坐标系（Reference Coordinate）：使用其他坐标系来考究自身的情况时使用的，常用于图形之间的对齐 以下是对各种坐标系之间的关系做的图，希望有助于大家理解 坐标变换 定义 数学上，是指采用一定的数学方法将一个坐标系的坐标变换成另一个坐标的坐标的过程。 SVG中，是指自身坐标系通过坐标变换后得到的新的自身坐标系的描述。 transform属性 定义前驱坐标系到自身坐标系的线性变换 语法： rotate() 定义元素的旋转 translate(,) 定义元素的平移 scale(,) 定义元素的x方向和y方向缩放 matrix(,,,,,) 定义变化矩阵，其实以上三种语法的本质原理就是改变matrix的值实现的变换，只是上面的表达更容易让人理解。 顺便讲一下matrix这个重点 矩阵的书写 矩阵实现变换的原理 例：matrix(1, 0, 0, 1, 30, 30) //a=1, b=0, c=0, d=1, e=30, f=30 假设原中心点为（0,0）即x=0,y=0, 则x的坐标ax+cy+e=10+00+30 = 30 ; y的坐标bx+dy+f=00+10+30 = 30 所以是原中心点变为了（30,30），元素实现了平移，不知道这么说大家对matrix会不会有一定的了解，如果还不懂则去百度一下吧 以下有一个关于transform的实例，大家可以操作一下，加深对transform属性的了解。 注：t 100 100 r30（先平移后旋转） 和 r30 t 100 100 （先旋转后平移）是不一样的，大家可以去操作理解一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;transform属性&lt;/title&gt; &lt;style media=&quot;screen&quot;&gt; svg&#123; background-color: #fcfcfc; display: block; margin: 20px auto; border: 1px solid #ccc; &#125; #transform&#123; width: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;fieldset&gt; &lt;legend&gt;设置&lt;/legend&gt; &lt;label for=&quot;&quot;&gt;分组： &lt;select id=&quot;group&quot;&gt; &lt;option value=&quot;a&quot;&gt;a&lt;/option&gt; &lt;option value=&quot;b&quot;&gt;┗b&lt;/option&gt; &lt;option value=&quot;c&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;┗c&lt;/option&gt; &lt;option value=&quot;d&quot;&gt;┗d&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt;变换： &lt;input type=&quot;text&quot; id=&quot;tc&quot; /&gt; &lt;span id=&quot;ts&quot;&gt;&lt;/span&gt; &lt;/label&gt; &lt;p&gt; 分组：选择相应的坐标系进行变换&lt;br&gt; 变换：&lt;br&gt; 旋转 r 100 &lt;=&gt; rotate(100)&lt;br&gt; 平移 t 100 100 &lt;=&gt; translate(100, 100)&lt;br&gt; 缩放 s 3 3 &lt;=&gt; scale(3, 3)&lt;br&gt; 集合 m a b c d e f &lt;=&gt; matrix(a, b, c, d, e, f) &lt;/p&gt;&lt;/fieldset&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;1000&quot; height=&quot;600&quot; viewBox=&quot;-200.5 -100.5 1000 600&quot;&gt; &lt;defs&gt; &lt;g id=&quot;coord&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;300&quot; y2=&quot;0&quot;/&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;300&quot;/&gt; &lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;2&quot;/&gt; &lt;circle cx=&quot;100&quot; cy=&quot;0&quot; r=&quot;2&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;0&quot; r=&quot;2&quot;/&gt; &lt;circle cx=&quot;0&quot; cy=&quot;100&quot; r=&quot;2&quot;/&gt; &lt;circle cx=&quot;0&quot; cy=&quot;200&quot; r=&quot;2&quot;/&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use xlink:href=&quot;#coord&quot; stroke=&quot;black&quot; fill=&quot;black&quot;/&gt; &lt;text fill=&quot;black&quot; x=&quot;5&quot; y=&quot;20&quot;&gt;World&lt;/text&gt; &lt;g id=&quot;a&quot; stroke=&quot;red&quot; fill=&quot;red&quot;&gt; &lt;use xlink:href=&quot;#coord&quot;/&gt; &lt;text x=&quot;5&quot; y=&quot;20&quot;&gt;a&lt;/text&gt; &lt;g id=&quot;b&quot; stroke=&quot;blue&quot; fill=&quot;blue&quot;&gt; &lt;use xlink:href=&quot;#coord&quot;/&gt; &lt;text x=&quot;5&quot; y=&quot;20&quot;&gt;b&lt;/text&gt; &lt;g id=&quot;c&quot; stroke=&quot;green&quot; fill=&quot;green&quot;&gt; &lt;use xlink:href=&quot;#coord&quot;/&gt; &lt;text x=&quot;5&quot; y=&quot;20&quot;&gt;c&lt;/text&gt; &lt;/g&gt; &lt;/g&gt; &lt;g id=&quot;d&quot; stroke=&quot;pink&quot; fill=&quot;pink&quot;&gt; &lt;use xlink:href=&quot;#coord&quot;/&gt; &lt;text x=&quot;5&quot; y=&quot;20&quot;&gt;d&lt;/text&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt;&lt;script&gt; function target() &#123; return document.getElementById(group.value); &#125; // 把变换命令转换为字符串 // &apos;t 10 10 r 30 s 1.3&apos; =&gt; &apos;translate(10, 10) rotate(30) scale(1.3)&apos; function tc2ts(tc) &#123; var arr = (tc || &apos;&apos;).split(&apos; &apos;); var ts = &apos;&apos;; var elem, lastElemType; var cmd = &#123; &apos;t&apos;: &apos;translate(&apos;, &apos;r&apos;: &apos;rotate(&apos;, &apos;s&apos;: &apos;scale(&apos;, &apos;m&apos;: &apos;matrix(&apos; &#125;; while ( elem=arr.shift() ) &#123; if ( cmd[elem] ) &#123; if ( lastElemType==&apos;number&apos; ) ts += &apos;) &apos;; ts += cmd[elem]; lastElemType = &apos;command&apos;; &#125; else &#123; if ( lastElemType==&apos;number&apos; ) ts += &apos;, &apos;; ts += elem; lastElemType = &apos;number&apos;; &#125; &#125; if ( ts.length ) ts += &apos;)&apos;; return ts; &#125; group.oninput = function() &#123; tc.value = target().tc || &apos;&apos;; ts.innerHTML = tc2ts(tc.value); &#125;; tc.oninput = function() &#123; target().tc = tc.value; target().setAttribute(&apos;transform&apos;, ts.innerHTML = tc2ts(tc.value)); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; SVG颜色、渐变和笔刷RGB和HSL RGB 红色、绿色、蓝色三个量值 表示方式有rgb(r, g, b) 或#rrggbb 每个分量取值范围：[0, 255] 优势：显示器容易解析，故比较常用 劣势：不符合人类描述颜色的习惯，修改颜色，暗度，亮度时需要改多个值。 HSL 颜色、饱和度、亮度三个分量 格式：hsl(h, s%, l%) 取值范围：h:[0, 359] s,l: [0, 100] 优势：符合人类描述颜色的习惯，顺便附上一个酷酷的hsl配色网站 http://paletton.com/ 透明度 rgba(r, g, b, a) 和 hsla(h, s%, l%, a) 表示带透明度的颜色 opacity属性表示元素的透明度 a和opacity的取值范围：[0, 1] 使用方法： 12 &lt;rect fill=&quot;rgb(255,0,0)&quot; opacity=&quot;0.5&quot;/&gt;&lt;rect stroke=&quot;hsla(0, 50%, 60%, 0.5)&quot;/&gt; 线性渐变和径向渐变 线性渐变 和 定义方向 关键点位置及颜色 gradientUnits用两个属性： objectBoundingBox 这是默认属性，使用x1=0, y1=0, x2=1, y2=1分别表示图形的最左端（0）， 最上端（0）， 最右端（1）， 最低端 （1） userSpaceOnUse 位置坐标使用世界坐标系，单位是px 注释：如没有设置gradientUnits属性，则默认使用objectBoundingBox 使用方法： 123456789101112131415 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;defs&gt; &lt;!--objectBoundingBox属性--&gt; &lt;linearGradient id=&quot;grad1&quot; gradientUnits=&quot;objectBoundingBox&quot; x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;1&quot; y2=&quot;1&quot;&gt; &lt;!--userSpaceOnUse属性--&gt; &lt;!--&lt;linearGradient id=&quot;grad1&quot; gradientUnits=&quot;userSpaceOnUse&quot;--&gt; &lt;!--x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;150&quot; y2=&quot;150&quot;&gt;--&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;#1497FC&quot;/&gt; &lt;stop offset=&quot;0.5&quot; stop-color=&quot;#A469BE&quot;/&gt; &lt;stop offset=&quot;1&quot; stop-color=&quot;#FF8C00&quot;/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; fill=&quot;url(#grad1)&quot; width=&quot;200&quot; height=&quot;150&quot;/&gt;&lt;/svg&gt; 径向渐变 和 定义方向 关键点位置及颜色 cx 和 cy gradientUnits 焦点位置 fx 和 fy 实例： 12345678910 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;defs&gt; &lt;radialGradient id=&quot;grad2&quot; cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.5&quot; fx=&quot;0.5&quot; fy=&quot;0.5&quot; &gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;rgb(20, 151, 252)&quot;/&gt; &lt;stop offset=&quot;0.5&quot; stop-color=&quot;rgb(164, 105, 190)&quot;/&gt; &lt;stop offset=&quot;1&quot; stop-color=&quot;rgb(255, 140, 0)&quot;/&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;200&quot; height=&quot;150&quot; fill=&quot;url(#grad2)&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 定义渐变上的颜色坡度，可以是线性渐变或径向渐变的子元素 offset 定义颜色百分比，取值范围：[0, 100%] stop-color 定义渐变颜色 stop-opacity 定义渐变透明度 使用笔刷 绘制文理 标签 patternUnits 和 patternContentUnits objectBoundingBox 这是默认属性，使用x1=0, y1=0, x2=1, y2=1分别表示图形的最左端（0）， 最上端（0）， 最右端（1），最低端 （1） userSpaceOnUse 位置坐标使用世界坐标系，单位是px 123456789 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;defs&gt; &lt;pattern id=&quot;grad2&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;0.25&quot; height=&quot;0.25&quot; patternUnits=&quot;objectBoundingBox&quot; patternContentUnits=&quot;objectBoundingBox&quot;&gt; &lt;circle cx=&quot;0.1&quot; cy=&quot;0.1&quot; r=&quot;0.1&quot; fill=&quot;red&quot;&gt;&lt;/circle&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;800&quot; height=&quot;300&quot; fill=&quot;url(#grad2)&quot; stroke=&quot;blue&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; # 首先问大家一个问题，你觉得以上图片是怎么画出来的？画板绘制？no，手绘？no.这是用path工具画出来的，怎么样？是不是瞬间觉得path很强大，那赶紧一起学习吧。 path高级教程Path概述 表示路径，一个强大的绘图工具 基本命令 M = moveto 移动当前位置 L = lineto 从当前位置绘制线段到指定位置 H = horizontal lineto 从当前位置绘制水平线到达指定地x坐标 V = vertical lineto 从当前位置绘制竖直线到达指定地y坐标 C = curveto 从当前位置绘制三次贝塞尔曲线到指定位置 S = smooth curveto 从当前位置光滑绘制三次贝塞尔曲线到指定位置 Q = quadratic Belzier curve 从当前位置绘制二次贝塞尔曲线到指定位置 T = smooth quadratic Belzier curveto 从当前位置光滑绘制二次贝塞尔曲线到指定位置 A = elliptical Arc 从当前位置绘制弧线到指定位置 Z = closepath 关闭路径 注释： 以上的翻译不一定是正确的，最好是自己使用一下属性然后理解一下它们的用处和原理 大写表示坐标参数为绝对定位，小写表示相对定位（相对上一次画笔所在位置）。 最后参数表示最终要到达的位置 命令可以重复参数表示重复执行同一条命令 例：复制一下文件，创建一个svg格式的文件，然后在浏览器中打开。 此例子定义了一条路径，开始于位置250 150， 到达位置150 350，然后再到350 350， 最后在250 150 关闭路径 12345678910 &lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;path d=&quot;M250 150 L150 350 L350 350 Z&quot; /&gt;&lt;/svg&gt; 效果图 移动和直线命令 M (x, y) + 移动画笔，一般是设置画笔开始位置，如果后面有重复参数则会当做L命令处理 L (x, y) + 绘制直线到指定位置 H (x) + 绘制水平线到指定的x位置 V (y) + 绘制竖直线到指定的y位置 如果使用小写 m、l、h、v 则是使用相对位置绘制 注：使用绝对坐标时，方便我们对图形整体（宏观）的把握，而使用相对坐标时，则有助于我们对图形的细节（微观）的把握，所以，按具体情况选择合适的命令格式。 弧线命令 A(rx, ry, xr, laf, sf, x, y) ——绘制弧线 rx - (radius-x) 弧线所在椭圆的x半轴长 ry - (radius-y) 弧线所在椭圆的y半轴长 xr - (xAxis-rotation) 弧线所在椭圆的长轴角度 laf - (large-arc-flag) 是否选择弧长较长的那一段弧 取值0（短弧） 或 1（长弧） sf - (sweep-flag) 是否选择逆时针方向的那一段弧 取值0（顺时针） 或 1（逆时针） x, y - 弧的终点位置 实例： 1234 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M 300 300 A 300 300 0 0 1 500 500&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot;/&gt; &lt;/svg&gt; 解释：下图可能画得有点杂乱，但你们那么强大，一眼就能看明白的。这是最为简单的一种画法，可以跟其他命令混合使用，如果设计感强的，可以利用这些命令制作出很精美的图片。 效果图 有兴趣的可以画一下下面这张图 贝塞尔曲线 SVG只能画二次贝塞尔曲线和三次贝塞尔曲线： 二次贝塞尔曲线 P0和P2是起始结点和终结点，而P1是P0和P2之外的点。绿线是由P0到P1时的结点和P1到P2时的结点产生，曲线由起始结点画线到终结点。 三次贝塞尔曲线 P0和P3是起始结点和终结点，而P1，P2是P0和P3之外的点。 二次贝塞尔曲线绘制命令 起始点 结束点 控制点 控制线 1M x0 y0 Q x1 y1 x y 三次贝塞尔曲线绘制命令 1M x0 y0 C x1 y1 x2 y2 x y 介绍一个牛人做的网站 http://myst729.github.io/bezier-curve/ 可以在线看到贝塞尔曲线的画线过程 光滑贝塞尔曲线 -T:Q的光滑版本 C1是上一段曲线的控制点关于当前曲线起始点的镜像位置 -S:C的简化版本 C1是上一段曲线的控制点2关于当前起始点的镜像位置 SVG文本 和 创建文本 x和y属性 - 定位标准 123 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;100&quot; style=&quot;font-size:50px &quot; &gt;ABCDE&lt;/text&gt;&lt;/svg&gt; dx和dy属性 - 字形偏移 123 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;100&quot; dx=&quot;20 20 20 20 20&quot; dy=&quot;20 20 20 20 20&quot; style=&quot;font-size:50px &quot; &gt;ABCDE&lt;/text&gt;&lt;/svg&gt; style属性 - 设置样式 直接对text元素设置属性 实例：以下一个动图，可自行下载到html文件中，在浏览器打开。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;svg&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;svg width=&quot;1200&quot; height=&quot;1000&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;defs&gt; &lt;pattern id=&quot;grid&quot; width=&quot;20&quot; height=&quot;20&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;path d=&quot;M0,0H20V20&quot; stroke-width=&quot;1&quot; stroke=&quot;#f0f0f0&quot; fill=&quot;none&quot;/&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;1200&quot; height=&quot;1000&quot; fill=&quot;url(#grid)&quot; stroke=&quot;&quot; stroke-width=&quot;&quot;/&gt; &lt;text x=&quot;100&quot; y=&quot;150&quot; font-size=&quot;14px&quot; font-family=&quot;Microsoft YaHei&quot;&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/text&gt; &lt;path d=&quot;M100,0V200M0,100H200&quot; stroke=&quot;red&quot; fill=&quot;none&quot; transform=translate(0,50) &gt;&lt;/path&gt;&lt;/svg&gt;&lt;script type=&quot;text/javascript&quot;&gt; var n = 26; var x = []; var y = null; var i = n; var s = 100; var w = 0.02; var t = 0.2; var sintext = document.getElementsByTagName(&apos;text&apos;)[0]; while(i--) x.push(20); function arrange(t) &#123; y = []; var ly = 0; var cy; for(i=0;i&lt;n;i++)&#123; cy = -s * Math.sin(w * i * 20 + t); y.push(cy - ly); ly = cy; &#125; &#125; function render() &#123; sintext.setAttribute(&quot;dx&quot;,x.join(&apos; &apos;)); sintext.setAttribute(&quot;dy&quot;,y.join(&apos; &apos;)); &#125; function frame() &#123; t += 0.01; arrange(t); render(); requestAnimationFrame(frame); &#125; frame();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; tspan为文本添加样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;svg&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;svg width=&quot;1200&quot; height=&quot;1000&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;defs&gt; &lt;pattern id=&quot;grid&quot; width=&quot;20&quot; height=&quot;20&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;path d=&quot;M0,0H20V20&quot; stroke-width=&quot;1&quot; stroke=&quot;#f0f0f0&quot; fill=&quot;none&quot;/&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;1200&quot; height=&quot;1000&quot; fill=&quot;url(#grid)&quot; stroke=&quot;&quot; stroke-width=&quot;&quot;/&gt; &lt;text x=&quot;100&quot; y=&quot;150&quot; font-size=&quot;20px&quot; font-family=&quot;Microsoft YaHei&quot;&gt;&lt;/text&gt; &lt;path d=&quot;M100,0V200M0,100H200&quot; stroke=&quot;red&quot; fill=&quot;none&quot; transform=translate(0,50) &gt;&lt;/path&gt;&lt;/svg&gt;&lt;script type=&quot;text/javascript&quot;&gt; var NS = &apos;http://www.w3.org/2000/svg&apos;; var text = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;; var n = text.length; var x = []; var y = null; var i = n; var s = 100; var w = 0.02; var t = 0.2; var sintext = document.getElementsByTagName(&apos;text&apos;)[0]; while(i--) &#123; x.push(20); var tspan = document.createElementNS(NS,&apos;tspan&apos;); tspan.textContent = text[n - i - 1]; sintext.appendChild(tspan); var h = Math.round(360 / 26 * i); tspan.setAttribute(&apos;fill&apos;,&apos;hsl(&apos; + h + &apos;, 100%, 80%)&apos;); &#125; function arrange(t) &#123; y = []; var ly = 0; var cy; for(i=0;i&lt;n;i++)&#123; cy = -s * Math.sin(w * i * 20 + t); y.push(cy - ly); ly = cy; &#125; &#125; function render() &#123; sintext.setAttribute(&quot;dx&quot;,x.join(&apos; &apos;)); sintext.setAttribute(&quot;dy&quot;,y.join(&apos; &apos;)); &#125; function frame() &#123; t += 0.01; arrange(t); render(); requestAnimationFrame(frame); &#125; frame();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 垂直居中问题 text-anchor - 水平居中属性 dominant-baseline 属性 让文本在制定路径上排序 使用方法 1234567891011121314151617 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;textPath路径文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;800&quot; height=&quot;600&quot;&gt; &lt;path id=&quot;path1&quot; d=&quot;M 100 200 Q 200 100 300 200 T 500 200&quot; stroke=&quot;rgb(0, 255, 0)&quot; fill=&quot;none&quot;/&gt; &lt;text style=&quot;font-size:14px;&quot;&gt; &lt;textPath xlink:href=&quot;#path1&quot;&gt; 欢迎来到shareclub！！！欢迎来到shareclub！！！欢迎来到shareclub！！！ &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 布局原理 浏览器从字体表中查出此字体的宽度，然后在曲线中找到相同的宽度，然后找一个中心点画出垂直坐标，然后把字体的基线对其到法线上。 最后一个点作为第二个字的第一个起点，然后以相同原理对齐 定位属性 x / dx：控制字体沿着曲线前后移动，超出曲线部分会被截取不显示 y：y对于文本没有任何作用 dy：在法线方向上下移动文本 text-anchor： -start 以字符串开头第一个字母为焦点对齐 -middle 以字符串中间的字母为焦点对齐 -end 以字符串最后一个字母为焦点对齐 startOffset：设置起始点 脚本控制 setAttributeNS() 方法设置xlink:href属性 把文本节点替换为节点 插入超链接 可以添加到任何的图形上 xlink:href 指定连接地址 xlink:title 指定连接提示 target 指定打开目标 12345678910111213141516171819202122 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;a超链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;a xlink:href=&quot;http://www.baidu.com&quot; xlink:title=&quot;百度&quot; target=&quot;_blank&quot;&gt; &lt;rect x=&quot;100&quot; y=&quot;100&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;rgba(255, 0, 0, 0.5&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot;&gt; &lt;/rect&gt; &lt;/a&gt;&lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; # 图形的引用、裁切和蒙版标签创建图形引用 实例：满天星星 标签裁切图形 实例：绘制灯塔的光线 标签创建蒙版 实例：绘制月牙及湖面倒影 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;starsky&lt;/title&gt; &lt;style&gt; html,body&#123; margin:0; padding:0; width:100%; height:100%; background:#001122; line-height:0; font-size:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;100%&quot; height=&quot;100%&quot; viewBox = &quot;-400 -300 800 600&quot; perserveAspectRatio=&quot;xMidYMid slice&quot;&gt; &lt;!--星星绘画：先画出一个星星，然后使用use画出同样形状，但不同大小的星星--&gt; &lt;defs&gt; &lt;polygon id=&quot;star&quot; points=&quot;0 -10 2 -2 10 0 2 2 0 10 -2 2 -10 0 -2 -2&quot; fill=&quot;white&quot;&gt;&lt;/polygon&gt; &lt;/defs&gt; &lt;!--真实事物--&gt;、 &lt;g id=&quot;real&quot;&gt; &lt;!--星星--&gt; &lt;g id=&quot;star-group&quot;&gt;&lt;/g&gt; &lt;!--使用group的好处：后期可以随之整体调整位置--&gt; &lt;!--月亮--&gt; &lt;g id=&quot;moon-group&quot;&gt; &lt;mask id=&quot;moon-mask&quot;&gt; &lt;!--月亮绘制：定义一个蒙版，然后通过蒙版设置能够通过蒙版的图形部分--&gt; &lt;circle cx=&quot;-250&quot; cy=&quot;-150&quot; r=&quot;100&quot; fill=&quot;white&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;-200&quot; cy=&quot;-200&quot; r=&quot;100&quot; fill=&quot;black&quot;&gt;&lt;/circle&gt; &lt;/mask&gt; &lt;circle cx=&quot;-250&quot; cy=&quot;-150&quot; r=&quot;100&quot; fill=&quot;yellow&quot; mask=&quot;url(#moon-mask)&quot;&gt;&lt;/circle&gt; &lt;/g&gt; &lt;!--灯塔--&gt; &lt;g id=&quot;light-tower&quot; transform=&quot;translate(255, 0)&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;tower&quot; x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;1&quot; y2=&quot;0&quot;&gt; &lt;!--设置灯塔渐变--&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;#999&quot;&gt;&lt;/stop&gt; &lt;stop offset=&quot;1&quot; stop-color=&quot;#333&quot;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;radialGradient id=&quot;light&quot; cx=&quot;0.5&quot; cy=&quot;0.5&quot; r=&quot;0.5&quot;&gt; &lt;!--设置灯光渐变--&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;rgba(255, 255, 255,.8&quot;&gt;&lt;/stop&gt; &lt;stop offset=&quot;1&quot; stop-color=&quot;rgba(255, 255, 255, 0)&quot;&gt;&lt;/stop&gt; &lt;/radialGradient&gt; &lt;clipPath id=&quot;light-clip&quot;&gt; &lt;!--clip裁剪路径--&gt; &lt;polygon points=&quot;0 0 -400 -15 -400 15&quot; fill=&quot;rgba(255,0,0,.5)&quot;&gt; &lt;!--动画效果--&gt; &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot; type=&quot;rotate&quot; from=&quot;0&quot; to=&quot;360&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;&gt; &lt;/animateTransform&gt; &lt;/polygon&gt; &lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;2&quot;&gt;&lt;/circle&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;polygon points=&quot;0 0 5 50 -5 50&quot; fill=&quot;url(#tower)&quot;&gt;&lt;/polygon&gt; &lt;!--光线绘画:先画一个椭圆，再画一个三角形，然后使用三角形对椭圆裁剪--&gt; &lt;ellipse cx=&quot;0&quot; cy=&quot;0&quot; rx=&quot;300&quot; ry=&quot;100&quot; fill=&quot;url(#light)&quot; clip-path=&quot;url(#light-clip)&quot;&gt;&lt;/ellipse&gt; &lt;!--调用裁剪路径，用三角形裁剪椭圆，形成光线--&gt; &lt;/g&gt; &lt;/g&gt; &lt;!--湖面镜像--&gt; &lt;g id=&quot;reflact&quot; transform=&quot;translate(0 50)&quot; mask=&quot;url(#fading)&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;fade&quot; x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;1&quot;&gt; &lt;stop offset=&quot;0&quot; stop-color=&quot;rgba(255,255,255,.3)&quot;&gt;&lt;/stop&gt; &lt;stop offset=&quot;0.5&quot; stop-color=&quot;rgba(255,255,255,0)&quot;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;mask id=&quot;fading&quot;&gt; &lt;rect x=&quot;-400&quot; y=&quot;0&quot; width=&quot;800&quot; height=&quot;300&quot; fill=&quot;url(#fade)&quot;&gt;&lt;/rect&gt; &lt;/mask&gt; &lt;/defs&gt; &lt;use xlink:href=&quot;#real&quot; transform=&quot;scale(1, -1) translate(0 -50)&quot; /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;script&gt; var SVG_NS = &apos;http://www.w3.org/2000/svg&apos;; var XLINK_NS = &apos;http://www.w3.org/1999/xlink&apos;; var paper = document.querySelector(&apos;svg&apos;); renderStar(); function use(origin)&#123; //使用use可以快速绘画多种相同的图形 var _use = document.createElementNS(SVG_NS, &apos;use&apos;); _use.setAttributeNS(XLINK_NS, &apos;xlink:href&apos;, &apos;#&apos; + origin.id); return _use; &#125; function random(min, max)&#123; return min + (max - min) * Math.random(); &#125; function renderStar()&#123; var starRef = document.getElementById(&apos;star&apos;); var starGroup = document.getElementById(&apos;star-group&apos;); var starCount = 500; var star; while(starCount--)&#123; star = use(starRef); star.setAttribute(&apos;opacity&apos;,random(0.1, 0.4)); star.setAttribute(&apos;transform&apos;, &apos;translate(&apos; + random(-400, 400) + &apos;,&apos; + random(-300, 50) + &apos;)&apos; + &apos;scale(&apos; + random(0.1, 0.6) + &apos;)&apos;); starGroup.appendChild(star); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; SVG动画动画原理 动画原理 SVG的动画原理跟flash的原理是一样的（以前有玩过flash的就知道了），在不同的帧设置不同的值，这样图形就会随着时间碎片的增加而产生动画效果。比如一个矩形，通过时间的差值，一帧一帧的改变设置某一个值比如x值，让其到达最终值，就会使矩形产生水平移动效果。 值-时间关系图 from 开始值 to 最终值 duration 动画时长 timing-function 动画曲线 frame 帧（1s切成24块，即24帧/s，人眼看到的就是一个连续的动画，如果要流畅的话，就60帧/s以上） interpolation 动画差值 创造并使用动画 内部资源标识符定位，即元素的id或class 1&lt;animate xlink:href=&quot;url(#rect1)&quot;&gt;&lt;/animate&gt; 包含在目标元素中 123 &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;200&quot;&gt; &lt;animate&gt;&lt;/animate&gt;&lt;/rect&gt; SMIL for SVG 参考资料： https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/ https://www.w3.org/TR/SVG/animate.html 动画标签： 基本动画 -attributeName 可以是元素名，或者样式名 -attributeType 代表动画是对XML属性（比如元素的位置变化） 还是 CSS样式（比如元素的颜色变化） -from 从开始值 -to 到最终值 -dur 设置动画时间 -repeatCount 属性值可以是数值（比如设置为100，则重复操作100次），也可以是indefinite，则一直循环操作 -fill 属性值freeze代表动画结束时保存最终值，不会变成开始值，即留在最后的位置；属性值remove代表动画结束时删除最终值，然后变回开始值，即返回开始位置 -begin 定义动画的开始时间，可以是数值，表达式 -calcMode 注：动画是可以叠加的（比如既可以设置移动，也可以设置颜色变化） 1234567 &lt;animate attributeType=&quot;XML&quot; attributeName=&quot;x&quot; from=&quot;10&quot; to=&quot;100&quot; dur=&quot;3s&quot;&gt;&lt;/animate&gt; 变换动画 -type rotate旋转 或 scale缩放 -from 从开始值 -to 到最终值 -dur 动画时间 注：不支持多个动画重叠 12345678910111213 &lt;svg viewBox=&quot;-400 -400 800 800&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;red&quot;&gt; &lt;animateTransform id=&quot;rotate&quot; attributeName=&quot;transform&quot; attributeType=&quot;XML&quot; type=&quot;rotate&quot; from=&quot;0&quot; to=&quot;360&quot; dur=&quot;3s&quot; &gt; &lt;/animateTransform&gt; &lt;/rect&gt;&lt;/svg&gt; 轨迹移动 -path 运动轨迹 -dur 动画时间 -rotate auto 根据路径的切线变化而旋转 123456789101112 &lt;svg viewBox=&quot;-400 -400 800 800&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;40&quot; height=&quot;40&quot; fill=&quot;red&quot;&gt; &lt;animateMotion path=&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; dur=&quot;5s&quot; rotate=&quot;auto&quot; &gt; &lt;/animateMotion&gt; &lt;/rect&gt; &lt;path id=&quot;motion-path&quot; d=&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; stroke=&quot;red&quot; fill=&quot;none&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 另一种添加路径方法 mpath 123456789101112 &lt;svg viewBox=&quot;-400 -400 800 800&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;40&quot; height=&quot;40&quot; fill=&quot;red&quot;&gt; &lt;animateMotion dur=&quot;5s&quot; rotate=&quot;auto&quot; &gt; &lt;mpath xlink:href=&quot;#motion-path&quot;&gt;&lt;/mpath&gt; &lt;/animateMotion&gt; &lt;/rect&gt; &lt;path id=&quot;motion-path&quot; d=&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; stroke=&quot;red&quot; fill=&quot;none&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 脚本动画 requestAnimationFrame(update) 通过脚本在每一个时间帧对当前元素属性的更新 实例：力导向图（存在引力和排斥力） 实例源代码： HTML代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;力导向图&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html,body,svg&#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg viewBox=&quot;-400 -400 800 800&quot;&gt; &lt;path d=&quot;&quot; stroke=&quot;gray&quot; fill=&quot;none&quot; id=&quot;links&quot;&gt;&lt;/path&gt; &lt;/svg&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;vector.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var points = &apos;a,b,c,d,e,f,g&apos;.split(&quot;,&quot;).map(function (name,index,arr) &#123; return &#123; name : name, color : &apos;hsl(&apos; + (360 * index / arr.length) + &quot;, 100%, 60%)&quot; &#125;; &#125;); var relation = 300; var k = 0.05; var svg = document.querySelector(&quot;svg&quot;); var Vector = window.Vector; function random(min,max) &#123; return Math.round(min + (max - min) * Math.random()); &#125; points.forEach(function (point) &#123; var circle = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;,&quot;circle&quot;); var x = random(-200,200); var y = random(-200,200); circle.setAttribute(&apos;cx&apos;,x); circle.setAttribute(&apos;cy&apos;,y); circle.setAttribute(&apos;r&apos;,10); circle.setAttribute(&apos;fill&apos;,point.color); svg.append(circle); point.circle = circle; point.s = new Vector(x,y); point.v = new Vector(); point.a = new Vector(); &#125;); // 上一帧时间 +new Date() 相当于 (new Date()).getTime(); var lastFrameTime = +new Date(); function update() &#123; // 当前帧时间 var frameTime = +new Date(); var t = frameTime - lastFrameTime; // 对时间t进行缩放 t /= 100; console.log(t); //点位置更新 points.forEach(function (pa) &#123; var f = new Vector(); //计算合力 points.forEach(function (pb) &#123; if (pa == pb) return; // x为一个矢量 var x = Vector.fromPoints(pa.s ,pb.s); // 弹性形变长度 var delta = x.length() - relation; // f = k * x; f = f.add(x.normalize(delta * k)); &#125;); pa.a = f; pa.v = pa.v.add(pa.a.multipy(t)).multipy(0.98); pa.s = pa.s.add(pa.v.multipy(t)); pa.circle.setAttribute(&apos;cx&apos;,pa.s.x); pa.circle.setAttribute(&apos;cy&apos;,pa.s.y); &#125;); //连线更新 var linkPath = []; points.forEach(function (pa) &#123; var sa = pa.s; points.forEach(function (pb) &#123; if (pa == pb) return; var sb = pb.s; linkPath = linkPath.concat([ &quot;M&quot;,sa.x,sa.y, &quot;L&quot;,sb.x,sb.y, ]); &#125;); &#125;); document.getElementById(&apos;links&apos;).setAttribute(&apos;d&apos;,linkPath.join(&apos; &apos;)); lastFrameTime = frameTime; window.requestAnimationFrame(update); &#125; window.requestAnimationFrame(update); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js代码： 1234567891011121314151617181920212223242526272829303132333435 ;(function () &#123; function Vector(x,y) &#123; this.x = x || 0; this.y = y || 0; &#125; Vector.prototype = &#123; constructor: Vector, square : function () &#123; return this.x * this.x + this.y * this.y; &#125;, length : function () &#123; // 返回平方根 return Math.sqrt(this.square()); &#125;, add : function (q) &#123; return new Vector(this.x + q.x,this.y + q.y); &#125;, minus : function (q) &#123; return new Vector(this.x - q.x,this.y - q.y); &#125;, multipy : function (scale) &#123; return new Vector(this.x * scale,this.y * scale); &#125;, normalize : function (length) &#123; if (length === undefined) &#123; length = 1; &#125; return this.multipy(length / this.length()); &#125; &#125;; Vector.fromPoints = function (p1,p2) &#123; return new Vector(p2.x - p1.x, p2.y - p1.y); &#125;; window.Vector = Vector;&#125;)() 效果图 本文内容是我自学的知识整理，其中的一些理解不一定正确，希望大家还是能够自己学习一下然后有自己的见解，如果与我的理解不一致，也希望能够留言指正。 附学习网址： w3school http://www.w3school.com.cn/svg/index.asp 慕课网 https://www.imooc.com/learn/143","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"http://yoursite.com/tags/SVG/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Java常用工具类","slug":"Java常用工具类","date":"2018-10-26T03:35:15.000Z","updated":"2019-09-03T09:28:06.865Z","comments":true,"path":"2018/10/26/Java常用工具类/","link":"","permalink":"http://yoursite.com/2018/10/26/Java常用工具类/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82667617 异常处理什么是异常？ 有异于常态，和正常状态不一样，有错误出现，阻止当前方法或作用域等等都称之为异常。 有什么常见异常？ 处理异常 try-catch 12345 try&#123; //一些会抛出异常的方法&#125;catch(Exception e)&#123; //处理该异常执行的代码块&#125; 多重异常处理 注意顺序问题：先子类后父类 12345678 try&#123; //一些会抛出异常的代码块&#125;catch(Exception e)&#123; //处理该异常的代码块&#125;catch(Exception 2)&#123; //处理Exception 2的代码块&#125;..(n个Exception)&#123; &#125; try-catch-finally 1234567 try&#123; //可能会抛出异常的代码&#125;catch(Exception e)&#123; //处理该异常的代码块&#125;finally&#123; //最终要执行的代码&#125; 自定义异常 Java异常数据库中存在了许多常见的异常，但是有时候我们需要一些在异常库中没有的异常怎么办呢？那就需要用到自定义异常。 自定义异常定义时要么跟数据库中的异常类似，要么就直接继承Exception类。 异常链 应用程序通常会通过抛出另一个异常来响应异常。 实际上，第一个异常引起第二个异常。 它可以是非常有助于用户知道什么时候一个异常导致另一个异常。 “异常链（Chained Exceptions）”帮助程序员做到这一点。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Javascript读取本地txt文件","slug":"Javascript读取本地txt文件","date":"2018-10-26T03:32:22.000Z","updated":"2019-09-03T09:28:53.277Z","comments":true,"path":"2018/10/26/Javascript读取本地txt文件/","link":"","permalink":"http://yoursite.com/2018/10/26/Javascript读取本地txt文件/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/83098474 以下代码实现javascript读取本地文件打印到浏览器中 12345678910111213141516 function load(name) &#123; let xhr = new XMLHttpRequest(), okStatus = document.location.protocol === &quot;file:&quot; ? 0 : 200; xhr.open(&apos;GET&apos;, name, false); xhr.overrideMimeType(&quot;text/html;charset=utf-8&quot;);//默认为utf-8 xhr.send(null); return xhr.status === okStatus ? xhr.responseText : null;&#125; let text = load(&quot;文件名.txt&quot;); console.log(text); //输出到浏览器控制器中//document.write(text); //打印在网页中//document.write(&quot;&lt;pre&gt;&quot;+text+&quot;&lt;pre/&gt;&quot;); //解决txt的换行无法打印到网页上的问题","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"WebStrom注册码2018-9-11","slug":"WebStrom注册码2018-9-11","date":"2018-10-16T14:26:57.000Z","updated":"2019-09-03T09:31:25.161Z","comments":true,"path":"2018/10/16/WebStrom注册码2018-9-11/","link":"","permalink":"http://yoursite.com/2018/10/16/WebStrom注册码2018-9-11/","excerpt":"","text":"之前的已经失效，可以访问此网址： http://idea.lanyus.com/","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"webStrom","slug":"webStrom","permalink":"http://yoursite.com/tags/webStrom/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Javascript——请和我互动吧","slug":"Javascript——请和我互动吧","date":"2018-10-12T17:55:09.000Z","updated":"2019-09-03T09:28:45.076Z","comments":true,"path":"2018/10/13/Javascript——请和我互动吧/","link":"","permalink":"http://yoursite.com/2018/10/13/Javascript——请和我互动吧/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/83034992 Javascript-输出内容（document.write） 用于直接向HTML输出流写内容，简而言之，就是直接在网页中输出内容。书写方法有四种： 第一种：输出内容用“”括起，直接输出“”号内的内容。 123 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;你好！欢迎来到shareclub博客！&quot;); &lt;/script&gt; 第二种：通过变量输出内容。 1234 &lt;script type=&quot;text/javascript&quot;&gt; var hello = &quot;你好！欢迎来到shareclub博客！&quot;; document.write(hello); &lt;/script&gt; 第三种：输出多项内容，内容之间通过+连接。 1234 &lt;script type=&quot;text/javascript&quot;&gt; var hello = &quot;你好！&quot;; document.write(hello + &quot;欢迎来到shareclub博客！&quot;); &lt;/script&gt; 第四种：输出HTML标签，并起作用，标签使用“”括起来。 123 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;h1&gt;你好！欢迎来到shareclub博客！&lt;/h1&gt;&quot;); &lt;/script&gt; ## Javascript-警告-消息对话框（document.alert） 向网页中弹出对话框，在弹窗显示内容。 1234567 &lt;script type=&quot;text/javascript&quot;&gt; var hello = &quot;你好！&quot;; alert(hello); //输出变量 alert(&quot;欢迎来到shareclub博客！&quot;); //输出字符串 &lt;/script&gt; 注意：多个alert会按顺序执行，并且需按下确定后，才会执行下一个alert。消息对话框通常用于调试程序。 Javascript-确认-消息对话框（document.confirm） 用于允许用户做选择的动作。包括一个确定和一个取消按钮。 12345 var i = comfirm(str);//str：在消息框显示的内容。//返回值：Boolean值。 实例： 12345678 &lt;script type=&quot;text/javascript&quot;&gt; var i = confirm(&quot;你是帅哥？&quot;); if(i == true)&#123; document.write(&quot;你是一位帅哥&quot;); &#125;else&#123; document.write(&quot;你是一位美女&quot;); &#125;&lt;/script&gt; Javascript-提问-消息对话框（document.prompt） 弹出对话框，收集一些需要与用户交互的信息。包括（一个确认和一个取消，一个输入框）。 1234 prompt(str1, str2);//str1是对话框显示的内容，不可修改//str2是输入框默认的内容，可以修改 点击确认，文本框中的内容会作为函数返回值返回。 点击取消，返回null。 12345678 &lt;script type=&quot;text/javascript&quot;&gt; var i = prompt(&quot;你的名字是：&quot;, &quot;请输入你的名字&quot;); if(i != null)&#123; alert(&quot;你好！&quot; + i); &#125;else&#123; alert(&quot;你好！&quot; + &quot;my friend&quot;); &#125;&lt;/script&gt; Javascript-打开新窗口（window.open） open()方法可以查找一个已经存在或者新建的浏览器窗口。 1234567 window.open([URL],[窗口名称],[参数字符串])//URL:窗口显示的网页路径或网址，可选参数，不选则窗口不显示任何文档//窗口名称：// _blank:在新窗口显示目标网页// _self:在当前窗口显示目标网页// _在框架的上部分显示目标网页 参数字符串添用于添加其他属性，可直接在http://www.w3school.com.cn/jsref/met_win_open.asp上面查询。 Javascript-关闭窗口（window.close） 12 window.close(); //关闭本窗口&lt;窗口对象&gt;.close(); //关闭指定窗口","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"javascript思维导图","slug":"javascript思维导图","date":"2018-10-12T17:06:02.000Z","updated":"2019-09-03T09:28:56.049Z","comments":true,"path":"2018/10/13/javascript思维导图/","link":"","permalink":"http://yoursite.com/2018/10/13/javascript思维导图/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81091267 最近我把一本关于Javascript的书看了一遍，书名叫《JavaScript基础教程》-莫振杰写的。个人觉得很适合Javascript初学者看。里面的内容比较通俗易懂，看下来也不会觉得晦涩难懂，很枯燥。另外我看完这本书后 ，用了一个思维导图软件画了一个思维导图，我在这贴出来，希望让初学者对Javascript有大概的了解。而这也是一种很好的总结复习方法。 我用的制图软件是 MindManager 另外还有个XMind 两个软件都可以在百度搜索下载。 欢迎大家收藏！！！点击放大查看会清晰点！！！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"闭包、原型链、继承","slug":"闭包、原型链、继承","date":"2018-10-11T09:21:35.000Z","updated":"2019-09-03T06:56:13.792Z","comments":true,"path":"2018/10/11/闭包、原型链、继承/","link":"","permalink":"http://yoursite.com/2018/10/11/闭包、原型链、继承/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82992580 闭包 闭包就是函数中的函数实现外层函数中的变量不释放。 先来看看这个代码 1234567891011 function a()&#123; var o=1 function b()&#123; console.log(o++) &#125; b()&#125;a() //输出1a() //还是输出1a() //仍然输出1 //继续调用a()，得到的结果还是1 为什么会出现这样的结果，原因是每次调用完a后，o会+1，但是这个o是函数b中的o，而且没有返回到a中，所以当下一次再调用a时，o仍然是1。这就是外层函数的变量释放。那么怎么才能使o累加呢，这就要用到闭包了。在看看下面的代码。 123456789 function a()&#123; var o=1 function b()&#123; console.log(o++) &#125; return b&#125;var c = a() //只调用一次ac(); c(); c(); //通过调用c就可以实现多次调用b，实现累加 原型链 在javascript中创建对象有三种方法 123456789 //第一种new Object()//第二种，是第一种的简写&#123;a:1&#125;//第三种，通过构造函数，然后new一个对象function a()&#123;&#125;new a() 为一个对象添加属性和方法则是有“ . ”来实现 一个对象.属性或方法，例： 12 a = &#123;b:1&#125;则a.b = 1 那如果要为一堆对象添加属性和方法，就要使用到原型。原型（prototype）就是一次性给一堆对象添加属性和方法的对象。 一堆对象.prototype.属性或方法，例： 12 a.prototype = &#123;b:1&#125;则：a.prototype.b = 1 这样，所有的对象都有相同的属性或者方法 那什么是原型链？ 一个构造函数可以实例出一个对象，而此构造函数通过prototype又可以被一个对象赋值，构造函数+原型+对象，周而复始，直到最后没有原型，就构成了原型链。 对于原型链，我们只需要记住如果javascript在当前对象中，找不到属性和方法，就会沿着原型链一直找下去，直到找到。 继承 通过复用其他类的属性或方法，来扩展自己的属性或方法。 在javascript中就是通过原型链进行继承的，例： 1234567891011121314 function a()&#123; this.a = 1&#125;function b()&#123; this.b = 2&#125;a.prototype = new b() //使用原型，a既有自己创建的属性，也扩展了b的属性var o = new a()console.log(o.a) //输出1console.log(o.b) //输出2 但这是存在一些问题的 1、无法通过实例化子类对象向父类中传递参数 解决方案：使用父类.call(this,参数) 传递参数。例: 123456789101112131415 function a(c)&#123; b.call(this,c) this.a = 1&#125;function b(c)&#123; this.b = c&#125;a.prototype = new b() var oa = new a(2)console.log(oa.a)console.log(oa.b) 2、如果只使用call方法，则通过原型给父类中添加属性和方法子类无法继承 解决方案：子类.prototype = new 父类，例： 1234567891011121314151617 function a(c)&#123; b.call(this,c) this.a = 1&#125;function b(c)&#123; this.b = c&#125;b.prototype.d = 4 //为父类添加新的属性a.prototype = new b() //必须使用prototype和call子类才能继承父类新添加的属性var oa = new a(2)console.log(oa.a)console.log(oa.d) 3、子类对象的构造函数指向的都是父类的构造函数 解决方案：子类.prototype.constructor = 子类，例： 123456789101112131415161718 function a(c)&#123; b.call(this,c) //1、通过call方法向父类中传参 this.a = 1&#125;function b(c)&#123; this.b = c&#125;b.prototype.d = 4 a.prototype = new b() //2、通过原型让子类可以使用父类新添加的属性a.prototype.constructor = a //3、把子类对象的构造函数指向子类var oa = new a(2)console.log(oa.constructor)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"MySQL安装教程","slug":"MySQL安装教程","date":"2018-10-04T13:28:21.000Z","updated":"2019-09-03T09:29:29.182Z","comments":true,"path":"2018/10/04/MySQL安装教程/","link":"","permalink":"http://yoursite.com/2018/10/04/MySQL安装教程/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82940547 下载网址：https://dev.mysql.com/downloads/installer/ 安装流程，默认直接下一步的过程我在这不显示出来，只说需要注意的地方。 1、同时最大的链接数选择20以上 2、端口设置，3306是默认端口，全世界通用，生产环境中最好不要使用此端口，因为大多数人都知道默认的，如果知道了你的电脑ip和数据库名，就很容易入侵你的数据库。不过如果是测试环境用的，可以不更改。然后添加到防火墙。 3、编码格式选择第三个，选择utf8，否则插入中文数据会出现编码错误。 4、添加path中，就可以不用手动配置环境变量的path 5、用户密码，以后登录数据库用到的密码。 6、最后一步，关键时刻，如果最后4个都打勾了，则安装成功，如果不是，则安装失败，解决方案MySql二次重装问题解决","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"MySql二次重装问题解决","slug":"MySql二次重装问题解决","date":"2018-10-04T13:05:53.000Z","updated":"2019-09-03T09:29:33.622Z","comments":true,"path":"2018/10/04/MySql二次重装问题解决/","link":"","permalink":"http://yoursite.com/2018/10/04/MySql二次重装问题解决/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82940421 如果想要重装MySQL，那么卸载后就必须清除所有与MySQL有关的文档。具体内容如下： 1、在控制面板卸载MySQL 2、然后找到mysql安装目录（一般为C:/Program Files）将MySQL文件夹全部删掉，即使是空的文件夹也要删掉。 3、打开C:\\ProgramData，找到MySQL文件夹，并将其删除（最关键的一步），C:\\ProgramData这个目录默认是隐藏的，不能直接看到这个目录，可以直接在c盘的搜索框中复制C:\\ProgramData这个路径找到MySQL文件夹删掉。 4、win+R运行cmd打开窗口，输入regedit，然后回车，打开注册表，在注册表(regedit)查询mysql，全部删除； 可能在以下目录，请都去查看是否有MySQL文件，然后删除。 1.HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL 目录 2.HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL 目录（） 3.HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL 目录 5 删除完之后重启电脑（如果有时间建议再次查看是否删除完后再重启电脑） 6重新安装一次","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"keywords":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/计算机基础/"}]},{"title":"IDEA安装与激活","slug":"IDEA安装与激活","date":"2018-10-02T05:33:20.000Z","updated":"2019-09-03T07:01:36.571Z","comments":true,"path":"2018/10/02/IDEA安装与激活/","link":"","permalink":"http://yoursite.com/2018/10/02/IDEA安装与激活/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82925465 什么是IDEA? IDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境（也可用于其他语言），IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。可以这么说，IDEA比Eclipse更好，更优化，更适合开发java程序。 下载JDK 下载JDK1.8 http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-windows-x64.exe?AuthParam=1538494807_c75a44178c9a0c66fa3e0e27e7eefbac 安装JDK 直接下一步，选择默认路径 配置环境 第一步：找到目录C:\\Program Files\\Java\\jdk1.8.0_171\\bin，复制此路径。 第二步：右击我的电脑-&gt;进入属性-&gt;高级系统设置-&gt;环境变量 第三步：找到Path,编辑Path,把C:\\Program Files\\Java\\jdk1.8.0_171\\bin粘贴到最后，注意要用英文分号间隔。 第四步：测试：win+R运行cmd打开命令行，分别输入javac和java -version，出现以下内容则安装成功。 下载IDEA 直接到官网下载：http://www.jetbrains.com/idea/ 安装及激活 第一步：安装过程直接next….next，当然，不想装在c盘，可以自己设置其他盘。 第二步：找到这个目录C:\\Windows\\System32\\drivers\\etc下的hosts文件 第三步：把hosts文件拖到桌面，然后在桌面用记事本打开，在最后粘贴这串字符0.0.0.0 account.jetbrains.com 第四步：把修改好的hosts再拖回原来的目录中。 第五步：运行IDEA，会弹出以下窗口。选择Activation code 第六步：浏览器打开http://idea.lanyus.com/ 获取注册码 第七步：把注册码copy到刚刚的弹窗中，然后点击ok便可以运行。（注册码亲测可用）","categories":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}],"keywords":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}]},{"title":"阿里云云翼计划2018——搭建个人网站","slug":"阿里云云翼计划2018——搭建个人网站","date":"2018-09-30T09:19:57.000Z","updated":"2019-09-03T06:58:31.786Z","comments":true,"path":"2018/09/30/阿里云云翼计划2018——搭建个人网站/","link":"","permalink":"http://yoursite.com/2018/09/30/阿里云云翼计划2018——搭建个人网站/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82911082 之前写过一个微官网的文章，介绍过阿里云对学生的一个优惠计划。在本文，我将带大家一步一步地在此计划下搭建一个demo项目。话不多说，直接上教程。 第一步：到云翼计划2018购买服务器：1、注册阿里云账号-&gt;2、完成实名认证-&gt;3、完成学生认证-&gt;4、购买服务器 前三步不用多说，直接按照步骤注册、认证就可以了。 服务器有轻量应用服务器和与服务器ECS，下图中也有相应介绍，两者的区别：轻量应用服务器与ECS服务器的性能是相差无几的，但是轻量服务器的缺点在于无法进行长时间持续的高负载占用，如果我们用轻量应用服务器来进行持续的渲染、转码、机器学习等持续高负载操作，就显得力不从心了。所以，如果只是个人博客，测试网站用的话，建议购买轻量的；如果是企业用、需要复杂处理计算的，就选择ECS。本文使用的是轻量应用服务器。 预装环境可默认，后面可更换其他环境；不同地域的服务器没有多大区别，直接默认吧。 第二步：购买成功后进入控制台 第三步：找到轻量服务器，找不到的话，直接输入关键字搜索。 第四步：重置密码，重置后要记住密码以及IP地址（公网），以后登录服务器上传项目要用到。如果默认系统不适合你，可以重置系统。 第五步：使用WinSCP管理服务器登录服务器，上传项目代码。winSCP的下载安装网址：https://help.aliyun.com/knowledge_detail/60132.html?spm=a2c4g.11186631.2.4.31b45949PuMI7V。同时，上面也有登录教程，本文直接使用账号密码登录。 第六步：上传代码：在本地找到自己的项目文件，在服务器找到/home/www/htdocs/目录。 第七步：选择本地文件，然后上传。我之前已经上传过了，所以服务器目录上已经存在项目文件了。 最后一步：测试：http://(第四步记录的IP地址），访问后，就能展示你的index.html了。 如果你想用自己的域名，可以购买一个域名，解析到你的IP地址，就可以通过域名访问了。不懂的，可以看我之前的微官网（六）——后端之搭建生产环境中的第三步、购买域名。 简单的介绍，希望对大家有用处，有错的地方，欢迎指正，谢谢！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Java基础语法","slug":"Java基础语法","date":"2018-09-10T03:14:29.000Z","updated":"2019-09-03T09:28:29.565Z","comments":true,"path":"2018/09/10/Java基础语法/","link":"","permalink":"http://yoursite.com/2018/09/10/Java基础语法/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/82215498 基础语法：关键字 有着特殊用途和意义的关键字，有大小写之分。 标识符 用来命名变量、常量，有大小写之分，以数子、字母、下划线_、美元符号$，不能以数字开头。 变量 变量：变量就好比一个用来装东西的盒子，不同类型的盒子装的东西不一样。盒子就是变量，不同类型的盒子就是不同类型的变量，里面的东西就是变量的值。 优秀码农的习惯： 1、当变量由多个单词组成时，第一个单词的首个字母小写，其余的首字母大写，这是骆驼命名法。例：myLove; 2、变量命名是要简短且清楚表达变量的作用，做到“见名知意”。 3、变量没有长度限制，但有大小写之分。 数据类型：Java是强类型语言，变量存储要分门别类。 基本数据类型存放的是数值本身，而引用数据类型存放的是数据的空间地址，基本数据类型就好比直接放东西进去抽屉，而引用类型则是存放这些抽屉的钥匙，钥匙和抽屉是一一对应的。 变量使用规则： 1、变量要先声明后使用。 2、可以声明的同时进行初始化。 1String love = &quot;I love java&quot;; 3、也可以先声明后初始化。 1String love; love = &quot;I love Java&quot;; 3、每次只能赋值一个值。 4、变量名尽量不要用中文，虽然编译器不会报错，但是会影响跨平台性。 自动类型转换：不同基本数据类型之间经常需要进行装换，以下int类型的数据可以直接赋值给double类型变量。 123 int score1 = 62;double scores2 = score1;System.out.println(score2); 转换规则： 1、目标类型能与源类型兼容。例double能兼容int，但char不能兼容int。 2、目标类型的范围要比源类型的大，比如double的字节为8，而int的字节为4，所以可以转换。 强制类型转换： 当自动转换类型无法进行，而有需要进行转换，例如int转换成double类型，由于int的字节小于double，转换是无法自动进行的，所以，这就需要用到强制类型转换。语法是：（目标类型）数值。 注：强制类型转换可能会造成数据丢失。 常量 值被设定后，程序编译运行过程中不会改变，这样提高了代码的高维护性。常量用final声明，并且同样需要声明类型。 1final SEX = &quot; 男生 &quot;; 注意：常量一般要用大写。 运算符 算术运算符：+ - * / % ++ – 逻辑运算符：&amp;&amp; || ！ 比较运算符：&gt; &lt; &lt;= &gt;= == != 赋值运算符：= += -+ *= /= %= 条件运算符：？： 流程控制语句 条件语句 if 先判断条件，条件满足则执行代码 123 if(条件)&#123; 条件满足执行的代码&#125; if…else 判断条件，满足执行第一个代码块，不满足执行第二个代码块。 1234567 if(条件)&#123; 条件满足执行的代码块&#125;else&#123; 条件不满足执行的代码块&#125; 多重if语句 条件1不满足，判断条件2，前面的条件都不满足，执行else后面的代码块 1234567 if(条件1)&#123; 条件1满足时执行的代码&#125;else if(条件2)&#123; 条件2满足时执行的代码&#125;else&#123; 前面的都不满足时执行的代码&#125; 嵌套if语句 只有外部if满足时，才能判断内部if 12345 if（外部条件）&#123; if（内部条件）&#123; 内部条件满足时执行的代码 &#125;&#125; switch 对许多条件使用等值判断 1234567891011121314 switch(变量) //括号内必须是整型或字符串&#123; case 变量1: &#123; //case后可以是常量，也可以是常量表达式 变量是变量1时执行的代码块 break; &#125; case 变量2: &#123; 变量是变量2时执行的代码块 break; &#125; default:&#123; 默认执行代码块 &#125;&#125; 循环语句 while 重复执行的代码 先判断，后执行 123 while(条件)&#123; 循环执行的代码&#125; do…while 先执行，后判断 判断条件一样时比while多执行了一次代码，注意while后的” ； “ 123 do&#123; 执行代码块&#125;while(判断条件); for(初始值; 判断条件; 递增) 这个是一般格式 1234 for(初始值; 判断条件; 递增)&#123; 循环操作代码块&#125; break 退出指定的循环，直接执行循环后面的代码 continue 跳出本次循环，直接执行下一个循环 两者区别：break是直接跳出整个循环，continue是跳出此次循环，剩余的循环继续进行 数组 数组就好比一个大盒子，可以存放多个同类型的数据。数组通过下标访问，下标从0开始。 1、声明数组 12 数据类型[] 数组名; //常用数据类型 数组名[]; 2、分配空间 1数组名 = new 数组类型[数组长度]; 注：声明同时可分配空间 1数组类型[] 数组名 = new 数组类型[数组长度]; 3、赋值 1数组名[下标] = 数值或字符; //赋值要跟数组类型相同","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"微官网（七）——上线","slug":"微官网（七）——上线","date":"2018-08-09T14:28:37.000Z","updated":"2019-09-03T06:58:40.596Z","comments":true,"path":"2018/08/09/微官网（七）——上线/","link":"","permalink":"http://yoursite.com/2018/08/09/微官网（七）——上线/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81164388 先说两句，等你购买了域名和服务器主机后，还需要对你的服务器配置环境才能运行网站文件的，服务器其实就是一台电脑，而这台电脑的IP是公开的，能够让所有人访问的。所以，部署服务器环境其实就是把之前你部署开发环境的流程重新做一遍而已。但是如果你买的服务器是Linux系统的，则要对Linux系统操作要有所了解，这里不讲解，可上网查询。我要说的是如何把网站的文件放上服务器，然后用域名对其访问。 使用工具：Filezilla 下载Filezilla 下载网址：https://www.filezilla.cn/ 选择下载客户端 选择系统、电脑位数、安装类型 安装版：下载的是安装程序，会有安装过程，文件较小。 绿色版：免安装，直接解压zip文件就能使用，文件较大。 打开程序、输入服务器信息进行连接。 如果不知道主机和用户名等信息在服务器在哪里，这里有个教程，连接成功后，就可以在服务器上上传下载文件了。 文件一般上传到htdocs文件夹中，上传完成后，就是通过域名解析，把在本地（这时的主机是指服务器）访问地址解析成你购买的域名，解析后尝试通过域名访问。 你会发现外网还是无法访问你的程序。这是因为在阿里云中必须配置一下安全组。进入阿里云管理控制台-&gt;云服务器ECS-&gt;网络和安全-&gt;安全组，这时会显示你的服务器列表，在你要修改的服务器右下角点击“配置规则”，显示出规则列表。 我们需要点击“添加安全组规则”，添加入方向，将8080，80端口添加进来。这时你再访问网站，就顺利的打开啦。 如果域名解析成功，可以直接用域名加8080端口访问，等域名备案成功后就可以直接用域名访问了。 到此，整个网站才最终完成。总结一下：个人搭建网站难度很大，而且如果没有足够的技术积累，是很难做出一个好的网站来的。所以，有很多企业建站要么使用外包，要么组建自己的开发团队去进行开发。跟大家说说他们的利弊。 外包建站：后期维护或修改困难，一般外包公司开发完丢给你就算了，最多送你个一年半载的保修期，但也最多在原生代码上做细微改动。另外，要是服务器也是使用它们假的，那你的运营数据、用户数据都掌握在别人手中，将来要迁移网站的时候就显得有些被动。优点就是开发速度快，流程简单，许多都是一条龙服务，交钱帮你全部搞定。 自己建站：开发困难，开发周期较长，开发成本相对较高，因为，你要养一个团队帮你弄网站。但是好处就是，什么都是掌握在自己手里，而且自己想怎么改就可以马上改，做出来的网站更符合自己的需求。 吹了那么多，这些也是个人经历过后总结出来的经验，如果有误，敬请谅解和指点。最后，希望需要建站的你们成功搭建出自己的网站。这个项目就到此结束了，感谢各位老铁的支持和阅读。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（六）——后端之搭建生产环境","slug":"微官网（六）——后端之搭建生产环境","date":"2018-08-09T14:08:44.000Z","updated":"2019-09-03T06:58:37.417Z","comments":true,"path":"2018/08/09/微官网（六）——后端之搭建生产环境/","link":"","permalink":"http://yoursite.com/2018/08/09/微官网（六）——后端之搭建生产环境/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81164370 网站的前端和后台都开发好后，我们需要搭建生产环境，也就是服务器。那么如何搭建呢？给大家讲解一下流程。服务器提供商有多个，大厂有腾讯、阿里云等，我所用的就是阿里云服务器。 部署需求：域名+空间，这两个都需要进行购买，两个都购买后则可以进行解析连接。 部署流程： 1、登录阿里云，没有账号则进行注册。 1.1填写个人信息 2、进入控制台 2.1 1）域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。也就是用户访问你网站时输入的网址。 2）云解析DNS：可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。可以说是IP地址的一个“面具”，这个面具更好看，容易记忆，方便用户访问网站。 3）云虚拟主机：一款虚拟主机产品，其具备高在线率、智能容错、正版系统、免备份、等多项优势，特别适用于对网站运行质量有较高要求的用户，在线率达99.9%。主机就是空间，放置你网站文件的地方。 3、购买域名 3.1先查询自己想设置的域名是否已被注册 3.2选择你自己喜欢的域名，加入清单，然后结算就完成购买了 不懂自己适合什么域名的可以参考域名分类 3.3、购买后需要备案（备案过程比较久，所以在你开发网站的时候就可以申请备案了） 4、购买空间：云虚拟主机，有很多价格，根据自己需求去购买，一般用于企业。 4.1、如果只是想玩玩而你又是学生的，阿里云有个云翼计划专门给学生优惠的，购买前需要认证。 4.3、如果你不是学生，也没关系，阿里云有很多免费套餐。 5、主机绑定域名 5.1、绑定域名前要确保域名已经备案好 6、域名解析、添加你绑定的域名就可以了 以上工作有点繁琐，希望大家要有耐心，一步一步地去完成。这些工作都是为后期部署前面开发好的网站而做准备的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（五）——后端之后台开发（2）","slug":"微官网（五）——后端之后台开发（2）","date":"2018-08-09T14:06:34.000Z","updated":"2019-09-03T06:58:52.932Z","comments":true,"path":"2018/08/09/微官网（五）——后端之后台开发（2）/","link":"","permalink":"http://yoursite.com/2018/08/09/微官网（五）——后端之后台开发（2）/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81543936 后台开发之前讲到了可以使用ThinkPHP框架进行快速开发，还提到了一个学习ThinkPHP的教程，如果大家还没学习的可以到前面文章中找到相应链接，当然也可以到网易云课堂，慕课网上面搜索课程，同时在ThinkPHP开发文档中也有教程，可以多去看看。这里我整理了一些ThinkPHP的基础知识，供大家学习参考。 MVC模型 Model模型：负责数据操作，数据分析 view视图（模板）：负责前台网页展示 前端 Controller控制器（模块）：负责描述功能 后台 入口文件1234567 &lt;?php define(&apos;THINK_PATH&apos;,&apos;./ThinkPHP/&apos;); define(&apos;APP_NAME&apos;,&apos;home&apos;); define(&apos;APP_PATH&apos;,&apos;./home/&apos;); require(THINK_PATH.&quot;ThinkPHP.php&quot;); APP::run(); ?&gt; 访问模板方法 1、模板相对路径 1234567 $this-&gt;display(); //直接调用$this-&gt;display(&quot;gg&quot;); //同控制器中调用其他模板$this-&gt;display(&quot;index:tt&quot;); //跨控制器调用模板$this-&gt;display(&quot;skinName@index:tt); //跨皮肤调用模板 ** 2、 全路径输出方式** 1$this-&gt;display(&quot;./Public/ss.html&quot;); //相对全路径调用模板 系统常量与模板替换12345 __ROOT__ //代表网站根目录地址（跨前台）__APP__ //当前项目的入口文档地址（跨控制器）__URL__ //当前操作所在模块的地址（同控制器下访问不同的action) 数据库配置 数据库连接方式：采用配置文件方式 12345678910111213 &lt;?php//home/Conf/config.php return array( &apos;DB_TYPE&apos; =&gt; &apos;mysql&apos;, //数据库类型 &apos;DB_HOST&apos; =&gt; &apos;localhost&apos;, //服务器地址 &apos;DB_NAME&apos; =&gt; &apos;demo&apos;, //数据库名 &apos;DB_USER&apos; =&gt; &apos;root&apos;, //用户名 &apos;DB_PWD&apos; =&gt; &apos;root&apos;, //密码 &apos;DB_PORT&apos; =&gt; 3306, //端口 &apos;DB_PREFIX&apos; =&gt; &apos;think_&apos;, //数据库前缀（推荐），设置后建表时表明须有前缀 &apos;DB_FIELDS_CACHE&apos; =&gt; true, //启用字段缓存（不推荐）);?&gt; 数据库实例模型 CURD与连贯操作 1、查询方式 12345 find(); //每次只查询一条记录，返回一个一维数组select(); //将该表中的所有信息读取出来，返回一个二维数组findAll(); //select()方法的别名 2、连贯操作 1$user-&gt;xxx-&gt;yyy-&gt;......-&gt;(增add删delete改save) 注：两端位置必须固定不变，中间的微连贯操作，顺序可以调换。 由于每个人的后台需求是不一样的，且有些东西需保密，所以，我就不展示自己的后台细节了。教程上面也有很多案例，可以跟着学习操作。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（五）——后端之后台开发（1）","slug":"微官网（五）——后端之后台开发（1）","date":"2018-08-06T15:52:38.000Z","updated":"2019-09-03T06:58:49.255Z","comments":true,"path":"2018/08/06/微官网（五）——后端之后台开发（1）/","link":"","permalink":"http://yoursite.com/2018/08/06/微官网（五）——后端之后台开发（1）/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81164350 前段时间跑去了当志愿者，所以项目就停止了，现在我们回顾一下之前讲过的一些东西。首先，讲了如何申请公众号并且对其进行简单的配置 。然后还讲了一下怎么进行前端开发，这个可以自己开发，但是要对HTML+CSS+Javascript、还有Jquery、bootstrap等要有所了解。后来是建议大家是直接到网上下载模板，经过修改后就能使用了，这种方法开发效率更高。然而，有些人认为这种方法这样不好，那样不好的，其实没什么不好的。据我了解，外面许多公司都是直接套模板的。现在是开源代码时代，别人分享出来的，为何不去用呢？是吧。这个见仁见智吧。接着，就教大家怎么去搭建后台开发环境，这个相对来说是比较简单的，一个集成环境软件就搞定了。 前端的页面都开发好了，后台开发环境也搭建好了，接下来就是要实现页面上的一些功能性的东西，比如用户注册、登录、下单，管理员上传、更新产品信息等等，就要设计到后台开发了。所以，本节我讲解一下如何开发后台。 一般网站都有一个前端网站+后台管理系统。前端网站就是浏览您的网站的用户所看到的的界面，而后台管理系统就是后台管理员对网站进行管理的一个平台。后台管理系统一般就是通过操作和管理数据库来处理和更新前端网站的数据、图片、文字等内容的，所以，这涉及了数据库的学习。 开发后台，作为初学者，我的建议是直接使用框架开发。可以使用基于PHP的ThinkPHP框架。但是，ThinkPHP说的就是php思想嘛，所以使用它之前，你必须对php有所了解吧。别担心，学一下PHP也花不了多少时间，可以一边学ThinkPHP，一边就把PHP也给学了。 那么如何学习ThinkPHP呢？上网海了个遍，在网易云课堂上面找了几个教程一起看，最后觉得北风网的深入浅出PHP框架Thinkphp实战开发是比较好的。基础加实战相结合，帮助大家更快地掌握Thinkphp（这个不是帮他打广告哈，只是个人感受）。这个教程我看到的是13年录制的，讲的是Thinkphp3.0的版本，现在已经是5.0的了，但是，这不重要，技术再怎么更新，最核心的内容还是不会有多大改变的，我自己在使用中也没有发现不兼容的情况。 后台开发的时间相对于前端开发是比较长的，而且涉及的东西还比较多。这篇算是作为一个承上启下的文章，所以，只说一些理论上的东西，技术方面的先不讲，后期我会陆续跟大家讲一下的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（四）——后端之搭建开发环境","slug":"微官网（四）——后端之搭建开发环境","date":"2018-07-24T02:50:25.000Z","updated":"2019-09-03T06:58:47.204Z","comments":true,"path":"2018/07/24/微官网（四）——后端之搭建开发环境/","link":"","permalink":"http://yoursite.com/2018/07/24/微官网（四）——后端之搭建开发环境/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81122945 俗话说得好：“工欲善其事，必先利其器”，我们想要搭建网站，就必须先配置好环境和安装好所需要的工具。接下来讲解一些知识和搭建过程。 后端部署流程 首先，先了解一下后台开发的一个详细流程。 搭建开发环境：写代码最终是放服务器上的，但代码在服务器上不方便些，所以在自己电脑配置各种软件工具，然后在本机写代码，本机就是开发环境。 后台开发：后台是管理后台管理员、用户管理、数据库管理等，可以称之为一个处理中心，处理前端发送过来的请求。 搭建生产环境：这是真正的服务器，代码就在上面运行，极其重要，每一项配置，任何的改动都应该极为小心，错误配置，很可能是服务器崩溃。 上线：就是把写好的代码放到生产环境中，然后让用户访问。比如，添加评论功能，在开发环境写好代码，上传到远程仓库，那么需要拉取、编译、重启tomcat、重启git.吧之前发布的流程重新来一遍。 搭建开发环境 搭建方法： 独立安装：把apache/tomcat(可选)、mysql、php、单独下载下来，然后安装配置，配置工作比较复杂，所以我在只对他们做个简单介绍。 PHP ： Hypertext Preprocessor 超文本预处理器， 是一种通用开源脚本语言，主要使用与Web开发领域。快速的执行动态网页，生成HTML标志。制作动态网页时使用。 MySql数据库：网站的一切数据都会放在数据库中，有字段、表、库、锁、实务、存储过程、范式等。如果对mysql不是很了解的，建议先到MySQL教程|菜鸟教程上面学习一下。 Apache ： 最流行的Web服务器端软件之一，快速、可靠、API扩充。项目的文件（HTML、CSS、JS等）都会放在Apache服务器上，其中会使用到8UFTP工具在本地上传文件到云服务器上。 Tomcat ： 网页服务器,客户端的请求、都被Tomcat接收、负责响应并返回资源。我们的整个项目的操作程序（java/python等）将放在Tomcat中。 集成安装： 作为初学者，我们可以去下载网站集成环境软件（phpStudy、XAMPP、wampServer）搭建开发环境。 XAMPP xampp软件可以直接到官网下载。安装过程，一直点next就好了。 打开xampp界面，打开apache、mysql、看到下面显示running则代表运行成功。 然后在浏览器输入localhost测试一下，弹出这个页面，就证明你安装成功了。 WampServer wampserver同样在它的官网中下可以下载，但这里有个更好的地址可以直接下载 安装过程一直下一步，中间会让你设置默认的浏览器，我是直接跳过，然后执行安装。后来再打开项目后，发现它直接用IE浏览器打开的。安装结束后，运行程序，在任务栏中会出现一个小图标，直至小图标显示绿色，则开始运行开发环境。 鼠标左键点击图标，会弹出这个操作界面。 点击localhost,或者在浏览器中输入localhost，弹出以下界面，则表示运行成功。至于界面上的其他操作，大家可以自行尝试操作，在这不做介绍，如果还是不懂，可以去看一下wampserver的教程。 phpStudy phpStudy也同样有自己的官网，直接到官网上下载软件安装包。 安装直接默认路径就可以了，phpStudy的安装做成最简单，也是最迅速的。安装后自动打开软件。软件的操作界面是这样的，点击启动即可打开apache和mysql。其他操作，在这不多做介绍。 在浏览器中输入localhost,弹出以下界面，则表示运行成功。 到此，三个集成开发环境的介绍就讲完了，这三个软件并没有好坏之分，就看哪个比较适合自己用，自己用得爽就好了。另外要注意的是，不能同时打开两个集成开发环境软件，因为他们的默认端口都是80，而一个端口只能对应一个程序，所以不能同时运行两个。当然，修改端口后，是可以同时运行的，但是这样做并无意义，也没这个必要。搞定上面的这些工作后，你就已经搭建好开发环境，可以在上面写项目了。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（三）——前端之制作网页","slug":"微官网（三）——前端之制作网页","date":"2018-07-23T03:02:41.000Z","updated":"2019-09-03T06:58:43.482Z","comments":true,"path":"2018/07/23/微官网（三）——前端之制作网页/","link":"","permalink":"http://yoursite.com/2018/07/23/微官网（三）——前端之制作网页/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81109503 开发一个网站，首先是前端开发，就是有个整体的网站页面的样子；如果就是后台开发，包括按钮、链接、增删查提，这些都需要后台编码；前端有了，后台也有了，那数据放哪里呢？所以就需要数据库了，姑且就叫做搭建数据库吧；这些都搞定后，在本地主机可以看网站了，但怎么让其他人也能看到呢？这就需要找到服务器发布了，就称之为网站发布吧；但是，网站发布出去后，想让别人统一用一个域名访问到网站怎么办呢？这就需要绑定域名了，这就叫域名绑定吧。这些工作都做完后，一个网站就成功搭建起来了。 整个步骤包括：前端开发-&gt;后台开发-&gt;搭建数据库-&gt;网站发布-&gt;域名绑定 本文讲解一下搭建网站中的第一个步骤，前端开发：前端网页的制作。这个需要做的有网站需求分析、原型设计、效果图、切图、美工，涉及知识有三剑客（HTML+CSS+JS）、jQuery、bootstrap等。在写网页时，希望大家对这些知识都有一定的基础。 具体步骤： 1、需求分析：设计好微官网的交互流程，确定好需要多少网页，需要什么功能。 2、原型设计：设计网页布局，特效，功能，交互方式。 3、创建好目录：HTML、CSS、JS、images四个主要目录。 4、切图：用PS或firework进行切图：图片、图标、logo等，把切好的图片素材放到images目录中 5、创建好html文件、css文件、js文件，分别放在对应的目录中，然后做好连接。css和js一般采用外联方式，便于维护 12 &lt;link href=&quot;../css/css文件地址&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;../js/js文件地址&quot;&gt;&lt;/script&gt; 6、根据之前设计好的方案写代码。 注意：如果不想自己做前端开发，网上有很多开源的网站模板，比如博客网站wordpress、17素材网（只做介绍，并非打广告）上面也有很多模板下载。 另外，提一下移动端前端开发：由于微官网是在手机上面显示的，这里需要解决自适应问题，我在这里列出了我遇到的问题和解决方法。 1、对自适应问题不太了解。 以前写的都是pc端网页，所以自适应问题还没接触过，然后就百度移动端自适应问题，在第一条博客文章中有着详细的说明，上面提到了四种解决方法，其中还详细介绍了网易和淘宝的方法。随后，我自认为百分比应该不是很难，然而，用百分比+媒体查询的方法使我的开发速度大大降低。原因是元素宽度是参考设备宽度而设置的，这个没问题，但高度没有参照啊，我要设置多少百分比呢？然后我就继续百度，找到了一个通过padding设置高度的方法，因为padding是参考宽度来设置的，所以有参照物，可以设置确定值。使用后确实解决了我的一些问题，网页也最终写出来了，但是元素没有设置高度，我总觉得会有问题，所以还是不推荐大家使用百分比的方法，我还是去好好学习一下网易和淘宝的方法，然后再去写其他网页。 2、移动端和pc端轮播广告的区别 轮播广告在移动端和pc端显示的效果差不多，移动端的效果相对简单，种类比较少；而pc端效果可以有很多。但是移动端跟pc端最大区别是手机是通过焦点交互，而电脑是通过鼠标，这两种不同的操作方式，就使两个有很大的差别。所以移动端要解决的问题是，如何实现左右切换幻灯片。我百度了一下，找到了一个素材jquery支持手机触屏的图片轮播效果，大概了解了一下，然后稍微修改了一下，应用到了自己的网页中，亲测了一下，完全可以用。（自己不懂怎么开发，可以上网找模块，然后稍微修改就能使用了，这样可以加快开发速度，但是对后期维护可能会有影响，所以建议套用后，要研究一下是如何实现的）。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"微官网（二）——配置公众号","slug":"微官网（二）——配置公众号","date":"2018-07-22T02:55:29.000Z","updated":"2019-09-03T06:58:34.309Z","comments":true,"path":"2018/07/22/微官网（二）——配置公众号/","link":"","permalink":"http://yoursite.com/2018/07/22/微官网（二）——配置公众号/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81123575 上文讲解了如何注册公众号，本文就讲解一下如何设置公众号，为后期链接到网站上做好准备。 1、登录公众号，输入账号密码 然后用管理员（注册公众号的人）或公众号运营则（之后可以在公众号绑定）微信扫码登录 2、登录公众号后，我们首先配置自定义菜单。 配置教程这里就不详细说了，百度上有个人公众号怎么开通自定义菜单 其他配置，我是通过绑定第三方平台微讯云端进行配置的 3、注册微讯云端，直接点立即注册，然后填写相关信息就好了，我已经注册过了，就直接登录 登录后界面 4、基础设置，绑定微信公众号、自动绑定即可 扫码自动绑定 5、绑定后，返回到管理面板，在功能模块中展示了很多功能，我们需要在公众号添加什么就直接点进去使用就好啦。 到这里，公众号的大概配置就讲完啦，现在许多公众号都是通过第三方平台进行功能扩展的，因为第三方可以让我们实现的功能有很多，而且大部分比公众号的原生功能好。然而，第三方平台有很多，有好有坏，在这里就不多做评论，我使用的是微讯云端，暂时是没发现有什么不好的地方，而且也能满足我的功能要求。 在公众号配置完成后，我会在自定义菜单中弄个接口，添加网站的链接上去，就可以实现跳转啦。所以，接下来，我需要做的，就是把网站搭建好就ok啦。老铁们，不知道这篇文章有没有让你们涨涨知识呢？欢迎在留言处给我留言，给我点建议或者分享一下你的看法吧。谢谢！！！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"CDSN博客皮肤设置","slug":"CDSN博客皮肤设置","date":"2018-07-19T15:11:44.000Z","updated":"2019-09-03T07:00:33.110Z","comments":true,"path":"2018/07/19/CDSN博客皮肤设置/","link":"","permalink":"http://yoursite.com/2018/07/19/CDSN博客皮肤设置/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81124279 当你看到其他博客主们的博客界面很好看的时候，是不是自己也想设置成这样的呢？不幸的是新版CDSN博客皮肤设置已下线，所以无法在上面直接切换其他皮肤。 幸运的是，这里有其他方法，也能切换到你喜欢的皮肤，具体步骤如下： 1、打开个人的博客设置，然后按f12打开审查元素，使用选择器，选择当前皮肤。你会在文件中看到有类名为：opt-skin-box的div，这些都是皮肤。所以要找到当前皮肤和你喜欢的皮肤的div。 2、打开两个div，找到里面的input元素中的value 和 id 3、交换两个input中的value 和 id 的值 4、交换后，要在页面进行保存 5、最后刷新一下页面，你就会发现已经切换到你喜欢的皮肤了，是不是很简单，赶紧试试切换到自己喜欢的皮肤吧。","categories":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://yoursite.com/tags/CSDN/"}],"keywords":[{"name":"IT资讯","slug":"IT资讯","permalink":"http://yoursite.com/categories/IT资讯/"}]},{"title":"微官网（一）——注册公众号","slug":"微官网（一）——注册公众号","date":"2018-07-18T17:00:09.000Z","updated":"2019-09-03T06:59:13.759Z","comments":true,"path":"2018/07/19/微官网（一）——注册公众号/","link":"","permalink":"http://yoursite.com/2018/07/19/微官网（一）——注册公众号/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81108125 最近在做一个公众号微官网项目，我把大概的流程写给大家看看，希望对有需要搭建微官网的老铁们有所帮助。同时，我也会把我在搭建过程中遇到的困难和解决方法，还有所用的工具和语言写出来，供大家参考。 项目介绍： 制作一个嵌套在公众号的微官网。 流程：1、注册公众号 2、搭建网站 3、连接公众号和网站 工作简介： 注册公众号：1、打开微信公众平台官网，然后注册一个公众号 2、根据自己需要选择公众号类型 1）订阅号：主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息； 2）服务号：主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息； 3）企业号：主要用于公司内部通讯使用，需要先验证身份才可以关注成功企业号。 温馨提示： 1）如果想简单的发送消息，达到宣传效果，建议可选择订阅号； 2）如果想用公众号获得更多的功能，例如开通微信支付，建议可以选择服务号； 3）如果想用来管理内部企业员工、团队，对内使用，可申请企业号； 4）订阅号可通过微信认证资质审核通过后有一次升级为服务号的入口，升级成功后类型不可再变； 5）服务号不可变更成订阅号。 6）服务号能够直接在用户的通讯录中找到，而订阅号都放在订阅号栏目中。 我要搭建的是企业需要的，所以申请服务号。 3、填写相关信息，然后等待审核。（注意：要确保信息准确，否则无法通过审核） 本文简单介绍了一下项目的流程，还有简单讲解了一下第一步公众号注册的过程。之后的步骤，我接下来会进行详细介绍。谢谢各位老铁的阅读，如果有哪里讲错了，欢迎留言指正，谢谢。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"搭建网站","slug":"搭建网站","permalink":"http://yoursite.com/tags/搭建网站/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"关于我","slug":"关于我","date":"2018-07-17T17:33:28.000Z","updated":"2019-09-03T06:57:48.252Z","comments":true,"path":"2018/07/18/关于我/","link":"","permalink":"http://yoursite.com/2018/07/18/关于我/","excerpt":"","text":"版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_39110538/article/details/81091219 各位读者，大家好,这是我的第一篇文章，日后，会有更多的文章记录我的编程经历和分享一些编程心得。 我是一名在校大二学生。高考选择了2+2国际班。然而，当我踏入大学后，我便对出国学习失去了兴趣，刚开始一直处于迷茫时期，但是经过两年的学习发展，我终于找到了方向。首先，我参加了一个公司的创立过程，从开始的找人才，商量模式，到后来的网站上线，业务开展，一年多的时间，我和公司老板还有许多志同道合的朋友们一起把公司建起来了。在这过程中，我学了前端三剑客（HTML+CSS+JS）、jQuery、bootstrap等前端技术，也因此，我发现了自己对前端产生了很大的兴趣。从此，我给自己定下了个目标方向。前期把熟练前端开发（这个阶段可能会持续很久），后期学习后端开发，成为一个全栈工程师（我知道这个目标很难实现，但梦想是要有的，万一实现了呢？）。从此，我就走上了前端的学习之路。 本人文笔水平一般，大家能懂意思就好了，可圈可点的地方也欢迎大家留言指点，谢谢大家！","categories":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/categories/程序人生/"}],"tags":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/tags/程序人生/"}],"keywords":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/categories/程序人生/"}]}]}